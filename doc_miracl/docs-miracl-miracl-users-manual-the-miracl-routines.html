<!DOCTYPE html>
<html>
  <head>

 <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" ">
<title>Docs MIRACL Users Manual The MIRACL Routines  | MIRACL</title>
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<link rel="stylesheet" type="text/css" href="css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="style/css/style.css">
<link rel="stylesheet" type="text/css" href="css/customstyles.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->







 

<script>
  $(function () {
      $('[data-toggle="tooltip"]').tooltip()
  })
</script>








  </head>

<body class="detail-page">

   <header>

  <nav class="navbar navbar-default navbar-fixed-top">
    <!-- We use the fluid option here to avoid overriding the fixed width of a normal container within the narrow content columns. -->
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-6" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          <img src="img/company-logo.svg">
        </a>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-6">

    <a href="#" class="default-btn outline pull-right">
      <span class="txt">open  miracl</span>
    </a>

    <ul class="nav navbar-nav">
      <!-- <li class="active"><a href="#">Home</a></li> -->
      <!-- <li class="dropdown">
      <a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">
      Services
      <span class="caret"></span>
      </a>
        <ul class="dropdown-menu" aria-labelledby="drop2">
          <li><a href="#">Dedicated Distributed Trust Aughthority</a></li>
          <li><a href="#">Cryptographic Engineering</a></li>
          <li role="separator" class="visible-xs divider"></li>
        </ul>
      </li>
      <li class="dropdown">
      <a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">
      Products
      <span class="caret"></span>
      </a>
        <ul class="dropdown-menu" aria-labelledby="drop2">
          <li><a href="#">Miracl Datacenter Cryptosystem</a></li>
          <li><a href="#">Miracl Crypto Libraries</a></li>
          <li role="separator" class="visible-xs divider"></li>
        </ul>
      </li> -->
      <li><a href="#">Products</a></li>
      <li><a href="#">Services</a></li>
      <li><a href="#">Resources</a></li>
      <!-- <li><a href="#">Crypto Labs</a></li> -->
      <li><a href="#">Success Stories</a></li>
      <!-- <li><a href="#">Community</a></li> -->
      <!-- <li><a href="#">Contact us</a></li> -->
    </ul>
      </div><!-- /.navbar-collapse -->

    </div>
  </nav>

</header>

    <div class="header-intro small text-center">
  <div class="dim"></div>
  <h1 class="title">Docs MIRACL Users Manual The MIRACL Routines</h1>
  <p class="title-desc">You'll definitely fall in love with this product.<span class="hidden-xs"><br></span>Itâ€™s like a missing part of your live.</p>
</div>

<div class="content-wrapper">
  <div class="container">
    <div class="row">

      <div class="col-xs-12 col-sm-8 col-md-9 desc-wrapper">

      <div class="content">
           

            
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

            
            <a href="https://github.com/tomjohnson1492/documentation-theme-jekyll/blob/gh-pages/docs-miracl-miracl-users-manual-the-miracl-routines.md" class="btn btn-default " role="button"><i class="fa fa-github fa-lg"></i> Edit me</a>
            

               <blockquote>
<p>Note: In these routines a <em>big</em> parameter can also be used wherever a <em>flash</em> &gt; is specified, but not visa-versa. Further information may be gleaned from the &gt; (lightly) commented source code. An asterisk * after the name indicates that
the function does not take a <em>mip</em> parameter if <strong>MR_GENERIC_MT</strong>  is
defined in <em>mirdef.h</em>. See Section 2.3 for more details.</p>
</blockquote>

<h2 id="9-1-low-level-routines">9.1  Low level routines</h2>

<h3 id="9-1-1-absol">9.1.1  absol *</h3>

<p><strong>Function:</strong>  void <strong>absol</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Gives absolute value of a big or flash number.</p>

<p><strong>Parameters:</strong>  Two big/flash variables <em>x</em> and <em>y</em>. On exit <em>y</em>=|<em>x</em>|.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-2-add">9.1.2  add</h3>

<p><strong>Function:</strong>  void <strong>add</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrarth0.c</p>

<p><strong>Description:</strong>  Adds two big numbers.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=x+y</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* This doubles the value of _x_. */</span>  
</code></pre></div>
<h3 id="9-1-3-brand">9.1.3  brand</h3>

<p><strong>Function:</strong>  int <strong>brand</strong>()</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Generates random integer number</p>

<p><strong>Parameters:</strong>  None</p>

<p><strong>Return Value:</strong>  A random integer number</p>

<p><strong>Restrictions:</strong>  First use must be preceded by an initial call to <strong>irand</strong>.</p>

<blockquote>
<p>Note: This generator is not cryptographically strong. For cryptographic
applications, use the <strong>strong_rng</strong> routine.</p>
</blockquote>

<h3 id="9-1-4-bigbits">9.1.4  bigbits</h3>

<p><strong>Function:</strong>  void <strong>bigbits</strong>(n,x)</p>

<p>int n;
big x;</p>

<p><strong>Module:</strong>  mrbits.c</p>

<p><strong>Description:</strong>  Generates a big random number of given length. Uses the built-in simple random number generator initialised by <strong>irand.</strong></p>

<p><strong>Parameters:</strong>  A big number <em>x</em> and an integers <em>n</em>. On exit <em>x</em> contains a big random number <em>n</em> bits long.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This generates a 100 bit random number</span>
    <span class="n">bigbits</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-5-big_to_bytes">9.1.5  big_to_bytes</h3>

<p><strong>Function:</strong>  int <strong>big_to_bytes</strong>(max,x,ptr,justify)</p>

<p>int max;
big x;
char *ptr;
BOOL justify</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Converts a positive big number <em>x</em> into a binary octet string</p>

<p><strong>Parameters:</strong>  A big number <em>x</em> and a byte array <em>ptr</em> of length <em>max</em>. Error checking is carried out to ensure that the function does not write beyond the limits of <em>ptr</em> if <em>max&gt;0</em>. If <em>max</em>=0, no checking is carried out. If <em>max</em>&gt;0 and <em>justify</em>=TRUE, the output is right-justified, otherwise leading zeros are suppressed.</p>

<p><strong>Return value:</strong>  The number of bytes generated in <em>ptr</em>. If <em>justify</em>=TRUE then the return value is <em>max</em>.</p>

<p><strong>Restrictions:</strong>  <em>max</em> must be greater than 0 if <em>justify</em>=TRUE  </p>

<h3 id="9-1-6-bytes_to_big">9.1.6  bytes_to_big</h3>

<p><strong>Function:</strong>  void <strong>bytes_to_big</strong>(len,ptr,x)</p>

<p>int len;
char *ptr;
big x;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Converts a binary octet string to a big number. Binary to big conversion.</p>

<p><strong>Parameters:</strong>  A pointer to a byte array <em>ptr</em> of length <em>len</em>, and a big result <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong> </p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*</span>
<span class="cm">     *  test program to exercise big_to_bytes() and bytes_to_big()</span>
<span class="cm">     */</span>

    <span class="cp">#include &lt;stdio.h&gt;</span>
    <span class="cp">#include &quot;miracl.h&quot;</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">;</span>
      <span class="n">miracl</span> <span class="o">*</span><span class="n">mip</span><span class="o">=</span><span class="n">mirsys</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">big</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
      <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span> <span class="cm">/* b needs space allocated to it */</span>
      <span class="n">x</span><span class="o">=</span><span class="n">mirvar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="cm">/* all big variables need to be &quot;mirvar&quot;ed */</span>
      <span class="n">y</span><span class="o">=</span><span class="n">mirvar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">expb2</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
      <span class="n">incr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* x=2^100 + 3 */</span>
      <span class="n">len</span><span class="o">=</span><span class="n">big_to_bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">FALSE</span><span class="p">);</span>

      <span class="cm">/* Now b contains big number x in raw binary */</span>
      <span class="cm">/* it is len bytes in length */</span>
      <span class="cm">/* now print out the raw binary number b in hex */</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02x&quot;</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">bytes_to_big</span><span class="p">(</span><span class="n">len</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>

      <span class="cm">/* now convert it back to big format, and print it out again */</span>
      <span class="n">mip</span><span class="o">-&gt;</span><span class="n">IOBASE</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span>
      <span class="n">cotnum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">stdout</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>  
</code></pre></div>
<h3 id="9-1-7-cinnum">9.1.7  cinnum</h3>

<p><strong>Function:</strong>  int <strong>cinnum</strong>(x,f)</p>

<p>flash x;
FILE *f;</p>

<p><strong>Module:</strong>  mrio2.c</p>

<p><strong>Description:</strong>  Inputs a flash number from the keyboard or a file, using as number base the current value of the instance variable IOBASE. Flash numbers can be entered using either a slash &#39;/&#39; to indicate numerator and denominator, or with a radix point.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a file descriptor <em>f</em>. For input from the keyboard specify <em>f</em> as <em>stdin</em>, otherwise as the descriptor of some other opened file. To force input of a fixed number of bytes, set the instance variable INPLEN to the required number, just before calling <strong>cinnum</strong>.</p>

<p><strong>Return value:</strong>  The number of input characters.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong>  mip-&gt;IOBASE=256;</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mip</span><span class="o">-&gt;</span><span class="n">INPLEN</span><span class="o">=</span><span class="mi">14</span><span class="p">;</span>  <span class="cm">/* This inputs 14 bytes from _fp_ and */</span>
    <span class="n">cinnum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>  <span class="cm">/* converts them into big number _x_  */</span>
</code></pre></div>
<h3 id="9-1-8-cinstr">9.1.8  cinstr</h3>

<p><strong>Function:</strong>  int <strong>cinstr</strong>(x,s)</p>

<p>flash x;
char *s;</p>

<p><strong>Module:</strong>  mrio2.c</p>

<p><strong>Description:</strong>  Inputs a flash number from a character string, using as number base the current value of the instance variable IOBASE. Flash numbers can be input using a slash &#39;/&#39; to indicate numerator and denominator, or with a radix point.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a string <em>s</em>.</p>

<p><strong>Return value:</strong>  The number of input characters.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/* input large hex number into big x */</span>
    <span class="n">mip</span><span class="o">-&gt;</span><span class="n">IOBASE</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span>
    <span class="n">cinstr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;AF12398065BFE4C96DB723A&quot;</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-9-compare">9.1.9  compare</h3>

<p><strong>Function:</strong>  int <strong>compare</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Compares two big numbers.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>y</em>.</p>

<p><strong>Return value:</strong>  Returns +1 if <em>x &gt; y</em>, returns 0 if <em>x = y</em>, returns -1 if <em>x &lt; y</em>.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-10-convert">9.1.10  convert</h3>

<p><strong>Function:</strong>  void <strong>convert</strong>(n,x)</p>

<p>int n;
big x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Convert an integer number to big number format.</p>

<p><strong>Parameters:</strong>  An integer <em>n</em> and a big number <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-11-copy">9.1.11  copy</h3>

<p><strong>Function:</strong>  void <strong>copy</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Copies a big or flash number to another.</p>

<p><strong>Parameters:</strong>  Two big or flash numbers <em>x</em> and <em>y</em>. On exit <em>y=x</em>. Note that if <em>x</em> and <em>y</em> are the same variable, no operation is performed.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-12-cotnum">9.1.12  cotnum</h3>

<p><strong>Function:</strong>  int <strong>cotnum</strong>(x,f)</p>

<p>flash x;
FILE *f;</p>

<p><strong>Module:</strong>  mrio2.c</p>

<p><strong>Description:</strong>  Output a big or flash number to the screen or to a file, using as number base the value currently assigned to the instance variable IOBASE. A flash number will be converted to radix-point representation if the instance variable RPOINT=ON. Otherwise it will be output as a fraction.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a file descriptor <em>f</em>. If <em>f</em> is <em>stdout</em> then output will be to the screen, otherwise to the file opened with descriptor <em>f</em>.</p>

<p><strong>Return value:</strong>  Number of output characters.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This outputs _x_ in hex, to the file associated with _fp_.</span>
    <span class="n">mip</span><span class="o">-&gt;</span><span class="n">IOBASE</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span>
    <span class="n">cotnum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-13-cotstr">9.1.13  cotstr</h3>

<p><strong>Function:</strong>  int <strong>cotstr</strong>(x,s)</p>

<p>flash x;
char *s;</p>

<p><strong>Module:</strong>  mrio2.c</p>

<p><strong>Description:</strong>  Output a big or flash number to the specified string, using as number base the value currently assigned to the instance variable IOBASE. A flash number will be converted to radix-point representation if the instance variable RPOINT=ON. Otherwise it will be output as a fraction.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a string <em>s</em>. On exit <em>s</em> will contain a representation of the number <em>x</em>.</p>

<p><strong>Return value:</strong>  Number of output characters.</p>

<p><strong>Restrictions:</strong>  Note that there is nothing to prevent this routine from overflowing the limits of the user supplied character array <em>s</em>, causing obscure runtime problems. It is the programmers responsibility to ensure that <em>s</em> is big enough to contain the number output to it. Alternatively use the internally declared instance string <strong>IOBUFF</strong>, which is of size <strong>IOBSIZ</strong>. If this array overflows a MIRACL error <strong>will</strong> be flagged.</p>

<h3 id="9-1-14-decr">9.1.14  decr**</h3>

<p><strong>Function:</strong>  void <strong>decr</strong>(x,n,z)</p>

<p>big x,z;
int n;</p>

<p><strong>Module:</strong>  mrarth0.c</p>

<p><strong>Description:</strong>  Decrement a big number by an integer amount.</p>

<p><strong>Parameters:</strong>  Big numbers <em>x</em> and <em>z</em>, and integer <em>n.</em></p>

<p>On exit <em>z=x-n</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None  </p>

<h3 id="9-1-15-divide">9.1.15  divide</h3>

<p><strong>Function:</strong>  void <strong>divide</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrarth2.c</p>

<p><strong>Description:</strong>  Divides one big number by another.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=x/y</em>; <em>x=x mod y</em>. The quotient only is returned if <em>x</em> and <em>z</em> are the same, the remainder only if <em>y</em> and <em>z</em> are the same.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Parameters <em>x</em> and <em>y</em> must be different, and <em>y</em> must be non-zero.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//This sets _x_ equal to the remainder when _x_ is divided by _y_. The quotient is not returned.</span>
<span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-16-divisible">9.1.16  divisible</h3>

<p><strong>Function:</strong>  BOOL <strong>divisible</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrarth2.c</p>

<p><strong>Description:</strong>  Tests a big number for divisibility by another</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>y</em>.</p>

<p><strong>Return value:</strong>  TRUE if <em>y</em> divides <em>x</em> exactly, otherwise FALSE</p>

<p><strong>Restrictions:</strong>  The parameter <em>y</em> must be non-zero.</p>

<h3 id="9-1-17-ecp_memalloc">9.1.17  ecp_memalloc</h3>

<p><strong>Function:</strong>  void *<strong>ecp_memalloc</strong>(n)</p>

<p>int n;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Reserves space for <em>n</em> elliptic curve points in one heap access. Individual points can subsequently be initialised from this memory by calling <strong>epoint_init_mem</strong>.</p>

<p><strong>Parameters:</strong>  The number <em>n</em> of elliptic curve points to reserve space for.</p>

<p><strong>Return value:</strong>  A pointer to the allocated memory.</p>

<p><strong>Restrictions:</strong>  None.</p>

<h3 id="9-1-18-ecp_memkill">9.1.18  ecp_memkill</h3>

<p><strong>Function:</strong>  void <strong>ecp_memkill</strong>(mem,n)</p>

<p>char *mem;
int n;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Deletes and sets to zero the memory previously allocated by <strong>ecp_memalloc</strong></p>

<p><strong>Parameters:</strong>  A pointer to the memory to be erased and deleted, and the size of that memory in elliptic curve points.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>ecp_memalloc</strong></p>

<h3 id="9-1-19-exsign">9.1.19  exsign</h3>

<p><strong>Function:</strong>  int <strong>exsign</strong>(x)</p>

<p>flash x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Extracts the sign of a big/flash number.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em>.</p>

<p><strong>Return value:</strong>  The sign of <em>x</em>, i.e. -1 if <em>x</em> is negative, +1 if <em>x</em> is zero or positive.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-20-getdig">9.1.20  getdig</h3>

<p><strong>Function:</strong>  int <strong>getdig</strong>(x,i)</p>

<p>big x;
int i;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Extracts a digit from a big number.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>, and the required digit <em>i</em>.</p>

<p><strong>Return value:</strong>  The value of the requested digit.</p>

<p><strong>Restrictions:</strong>  Returns rubbish if required digit does not exist.</p>

<h3 id="9-1-21-get_mip">9.1.21  get_mip</h3>

<p><strong>Function:</strong>  miracl *<strong>get_mip</strong>(void)</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Get the current Miracl Instance Pointer</p>

<p><strong>Parameters:</strong>  None</p>

<p><strong>Return value:</strong>  The <em>mip</em> - Miracl Instance Pointer â€“ for the current thread.</p>

<p><strong>Restrictions:</strong>  This function does not exist if <strong>MR_GENERIC_MT</strong> is defined.  </p>

<h3 id="9-1-22-igcd">9.1.22  igcd</h3>

<p><strong>Function:</strong>  int <strong>igcd</strong>(x,y)</p>

<p>int x,y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Calculates the Greatest Common Divisor of two integers using Euclids Method.</p>

<p><strong>Parameters:</strong>  Two integers <em>x</em> and <em>y</em></p>

<p><strong>Return value:</strong>  The GCD of <em>x</em> and <em>y</em></p>

<h3 id="9-1-23-incr">9.1.23  incr</h3>

<p><strong>Function:</strong>  void <strong>incr</strong>(x,n,z)</p>

<p>big x,z;
int n;</p>

<p><strong>Module:</strong>  mrarth0.c</p>

<p><strong>Description:</strong>  Increment a big variable.</p>

<p><strong>Parameters:</strong>  Big numbers <em>x</em> and <em>z</em>, and an integer <em>n</em>. On exit <em>z=x+n</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong>  incr(x,2,x);  /* This increments x by 2. */</p>

<h3 id="9-1-24-init_big_from_rom">9.1.24  init_big_from_rom</h3>

<p><strong>Function:</strong>  BOOL <strong>init_big_from_rom</strong>(big,int,const mr_small*,int,int*)</p>

<p>big x;
int len;
const mr_small *rom;
int romsize;
int *romptr;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialises a big variable from ROM memory.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em> and its length in computer words. The address of ROM memory which stores up to <em>romsize</em> computer words, and a pointer into the ROM. This pointer is incremented internally as ROM memory is accessed to fill <em>x</em>.</p>

<p><strong>Return value:</strong>  TRUE if successful, or FALSE if an attempt is made to read beyond the end of the ROM</p>

<h3 id="9-1-25-init_point_from_rom">9.1.25  init_point_from_rom</h3>

<p><strong>Function:</strong>  BOOL <strong>init_point_from_rom</strong>(epoint *,int,const mr_small*,int,int*)</p>

<p>epoint *P;
int len;
const mr_small *rom;
int romsize;
int *romptr;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialises an elliptic curve point from ROM memory.</p>

<p><strong>Parameters:</strong>  An elliptic curve point <em>P</em> and its length of its two big coordinates in computer words. The address of ROM memory which stores up to <em>romsize</em> computer words, and a pointer into the ROM. This pointer is incremented internally as ROM memory is accessed to fill <em>P</em>.</p>

<p><strong>Return value:</strong>  TRUE if successful, or FALSE if an attempt is made to read beyond the end of the ROM</p>

<h3 id="9-1-26-innum">9.1.26  innum</h3>

<p><strong>Function:</strong>  int <strong>innum</strong>(x,f)</p>

<p>flash x;
FILE *f;</p>

<p><strong>Module:</strong>  mrio1.c</p>

<p><strong>Description:</strong>  Inputs a big or flash number from a file or the keyboard, using as number base the value specified in the initial call to <strong>mirsys</strong>. Flash numbers can be entered using either a slash &#39;/&#39; to indicate numerator and denominator, or with a radix point.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a file descriptor <em>f</em>. For input from the keyboard specify <em>f</em> as <em>stdin</em>, otherwise as the descriptor of some other opened file.</p>

<p><strong>Return value:</strong>  The number of characters input.</p>

<p><strong>Restrictions:</strong>  The number base specified in <strong>mirsys</strong> must be less than or equal to 256. If not use <strong>cinnum</strong> instead.</p>

<p><strong>Hint:</strong>  For fastest inputting of ASCII text to a big number, and if a full-width base is possible, use mirsys(...,256); initially. This has the same effect as specifying mirsys(...,0);, except that now ASCII bytes may be input directly via innum(x,fp); without the time-consuming change of base implicit in the use of <strong>cinnum</strong>.</p>

<h3 id="9-1-27-insign">9.1.27  insign</h3>

<p><strong>Function:</strong>  void <strong>insign</strong>(s,x)</p>

<p>int s;
flash x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Forces a big/flash number to a particular sign.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em>, and the sign <em>s</em> that it is to take. On exit <em>x=s.|x</em>|.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">insign</span><span class="p">(</span><span class="n">PLUS</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* force _x_ to be positive */</span>  
</code></pre></div>
<h3 id="9-1-28-instr">9.1.28  instr</h3>

<p><strong>Function:</strong>  int <strong>instr</strong>(x,s)</p>

<p>flash x;
char *s;</p>

<p><strong>Module:</strong>  mrio1.c</p>

<p><strong>Description:</strong>  Inputs a big or flash number from a character string, using as number base the value specified in the initial call to <strong>mirsys</strong>. Flash numbers can be entered using either a slash &#39;/&#39; to indicate numerator and denominator, or with a radix point.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em> and a character string <em>s</em>.</p>

<p><strong>Return value:</strong>  The number of characters input.</p>

<p><strong>Restrictions:</strong>  The number base specified in <strong>mirsys</strong> must be less than or equal to 256. If not use <strong>cinstr</strong> instead.</p>

<h3 id="9-1-29-irand">9.1.29  irand</h3>

<p><strong>Function:</strong>  void <strong>irand</strong>(seed)</p>

<p>long seed;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initializes internal random number system. Long integer types are used internally to yield a generator with maximum period.</p>

<p><strong>Parameters:</strong>  A long integer seed, which is used to start off the random number generator.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-30-lgconv">9.1.30  lgconv</h3>

<p><strong>Function:</strong>  void <strong>lgconv</strong>(ln,x)</p>

<p>long ln;
big x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Converts a long integer to big number format</p>

<p><strong>Parameters:</strong>  A long integer <em>ln</em> and a big number <em>x</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-31-mad">9.1.31  mad</h3>

<p><strong>Function:</strong>  void <strong>mad</strong>(x,y,z,w,q,r)</p>

<p>big x,y,z,w,q,r;</p>

<p><strong>Module:</strong>  mrarth2.c</p>

<p><strong>Description:</strong>  Multiply add and divide big numbers. The initial product is stored in a double-length internal variable to avoid the possibility of overflow at this stage.</p>

<p><strong>Parameters:</strong>  Six big numbers <em>x,y,z,w,q</em> and <em>r</em>. On exit <em>q=(x.y+z)/w</em> and <em>r</em> contains the remainder. If <em>w</em> and <em>q</em> are not distinct variables then only the remainder is returned; if <em>q</em> and <em>r</em> are not distinct then only the quotient is returned. The addition of <em>z</em> is not done if <em>x</em> and <em>z</em> (or <em>y</em> and <em>z</em>) are the same.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Parameters <em>w</em> and <em>r</em> must be distinct. The value of <em>w</em> must not be zero.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">);</span> <span class="cm">/* _x=x^2/w_ */</span>
</code></pre></div>
<h3 id="9-1-32-memalloc">9.1.32  memalloc</h3>

<p><strong>Function:</strong>  void *<strong>memalloc</strong>(n)</p>

<p>int n;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Reserves space for <em>n</em> big variables in one heap access. Individual big/flash variables can subsequently be initialised from this memory by calling <strong>mirvar_mem</strong>.</p>

<p><strong>Parameters:</strong>  The number <em>n</em> of big/flash variables to reserve space for.</p>

<p><strong>Return value:</strong>  A pointer to the allocated memory.</p>

<p><strong>Restrictions:</strong>  None.  </p>

<h3 id="9-1-33-memkill">9.1.33  memkill</h3>

<p><strong>Function:</strong>  void <strong>memkill</strong>(mem,n)</p>

<p>char *mem;
int n;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Deletes and sets to zero the memory previously allocated by <strong>memalloc</strong></p>

<p><strong>Parameters:</strong>  A pointer to the memory to be erased and deleted, and the size of that memory in bigs.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>memalloc</strong></p>

<h3 id="9-1-34-mirexit">9.1.34  mirexit</h3>

<p><strong>Function:</strong>  void <strong>mirexit</strong>()</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Cleans up after the current instance of MIRACL, and frees all internal variables. A subsequent call to <strong>mirsys</strong> will re-initialise the MIRACL system.</p>

<p><strong>Parameters:</strong>  None</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be called after <strong>mirsys</strong>.</p>

<h3 id="9-1-35-mirkill">9.1.35  mirkill</h3>

<p><strong>Function:</strong>  void <strong>mirkill</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Securely kills off a big/flash number by zeroising it, and freeing its memory.</p>

<p><strong>Parameters:</strong>  A big/flash number <em>x</em>.</p>

<p><strong>Return Value:</strong> None  </p>

<h3 id="9-1-36-mirsys">9.1.36  mirsys</h3>

<p><strong>Function:</strong>  miracl <em>**mirsys</em>*(nd,nb)</p>

<p>int nd,nb;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialise the MIRACL system for the current program thread, as described below. Must be called before attempting to use any other MIRACL routines.</p>

<p>(1)  The error tracing mechanism is initialised.</p>

<p>(2)  the number of computer words to use for each big/flash number is calculated from <em>nd</em> and <em>nb</em>.</p>

<p>(3)  Sixteen big work variables (four of them double length) are initialised.</p>

<p>(4)  Certain instance variables are given default initial values.</p>

<p>(5)  The random number generator is started by calling <strong>irand(0L)</strong>.</p>

<p><strong>Parameters:</strong>  The number of digits <em>nd</em> to use for each big/flash variable and the number base <em>nb</em>. If <em>nd</em> is negative it is taken as indicating the size of big/flash numbers in 8-bit bytes.</p>

<p><strong>Return value:</strong>  The Miracl Instance Pointer, via which all instance variables can be accessed, or NULL if there was not enough memory to create an instance.</p>

<p><strong>Restrictions:</strong>  The number base <em>nb</em> should normally be greater than 1 and less than or equal to MAXBASE. A base of 0 implies that the &#39;full-width&#39; number base should be used. The number of digits <em>nd</em> must be less than a certain maximum, depending on the underlying type <em>mr_utype</em> and on whether or not <strong>MR_FLASH</strong> is defined. (See <em>mirdef.h</em>)</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//This initialises the MIRACL system to use 500 decimal digits for each big or flash number.</span>
<span class="n">miracl</span> <span class="o">*</span><span class="n">mip</span><span class="o">=</span><span class="n">mirsys</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-37-mirvar">9.1.37  mirvar</h3>

<p><strong>Function:</strong>  flash <strong>mirvar</strong>(iv)</p>

<p>int iv;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialises a big/flash variable by reserving a suitable number of memory locations for it. This memory may be released by a subsequent call to the function <strong>mirkill</strong>.</p>

<p><strong>Parameters:</strong>  An integer initial value for the big/flash number.</p>

<p><strong>Return value:</strong>  A pointer to the reserved memory.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//Creates a flash variable _x=8_.</span>
    <span class="n">flash</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="o">=</span><span class="n">mirvar</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-38-mirvar_mem">9.1.38  mirvar_mem</h3>

<p><strong>Function:</strong>  flash <strong>mirvar_mem</strong>(mem,index)</p>

<p>char *mem;
int index;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialises memory for a big/flash variable from a pre-allocated byte array <em>mem</em>. This array may be created from the heap by a call to <strong>memalloc</strong>, or in some other way. This is quicker than multiple calls to <strong>mirvar</strong>.</p>

<p><strong>Parameters:</strong>  A pointer to the pre-allocated array <em>mem</em>, and an index into that array. Each index should be unique.</p>

<p><strong>Return value:</strong>  An initialised big/flash variable</p>

<p><strong>Restrictions:</strong>  Sufficient memory must have been allocated and pointed to by <em>mem</em>.</p>

<p><strong>Example:</strong>  See <em>brent.c</em> for an example of use.</p>

<h3 id="9-1-39-multiply">9.1.39  multiply</h3>

<p><strong>Function:</strong>  void <strong>multiply</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrarth2.c</p>

<p><strong>Description:</strong>  Multiplies two big numbers</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x,y</em> and <em>z</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-40-negify">9.1.40  negify</h3>

<p><strong>Function:</strong>  void <strong>negify</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Negates a big/flash number.</p>

<p><strong>Parameters:</strong>  Two big/flash numbers <em>x</em> and <em>y</em>. On exit <em>y=-x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None. Note that negify(x,x) is valid and sets <em>x=-x</em></p>

<h3 id="9-1-41-normalise">9.1.41  normalise</h3>

<p><strong>Function:</strong>  int <strong>normalise</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrarth2.c</p>

<p><strong>Description:</strong> Multiplies a big number such that its Most Significant Word is greater than half the number base. If such a number is used as a divisor by <strong>divide</strong>, the division will be carried out faster. If many divisions by the same divisor are required, it makes sense to normalise the divisor just once beforehand.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>y</em>. On exit <em>y=n.x</em>.</p>

<p><strong>Return value:</strong>  Returns <em>n</em>, the normalising multiplier.</p>

<p><strong>Restrictions:</strong>  Use with care. Used internally.</p>

<h3 id="9-1-42-numdig">9.1.42  numdig</h3>

<p><strong>Function:</strong>  int <strong>numdig</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Determines the number of digits in a big number.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>.</p>

<p><strong>Return value:</strong>  The number of digits in <em>x</em>.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-43-otnum">9.1.43  otnum</h3>

<p><strong>Function:</strong>  int <strong>otnum</strong>(x,f)</p>

<p>flash x;
FILE *f;</p>

<p><strong>Module:</strong>  mrio1.c</p>

<p><strong>Description:</strong> Output a big or flash number to the screen or to a file, using as number base the value specified in the initial call to <strong>mirsys</strong>. A flash number will be converted to radix-point representation if the instance variable RPOINT=ON. Otherwise it will be output as a fraction.</p>

<p><strong>Parameters:</strong> A big/flash number <em>x</em> and a file descriptor <em>f</em>. If <em>f</em> is <em>stdout</em> then output will be to the screen, otherwise to the file opened with descriptor <em>f</em>.</p>

<p><strong>Return value:</strong>  Number of output characters.</p>

<p><strong>Restrictions:</strong> The number base specified in <strong>mirsys</strong> must be less than or equal to 256. If not, use <strong>cotnum</strong> instead.</p>

<h3 id="9-1-44-otstr">9.1.44 otstr</h3>

<p><strong>Function:</strong>  int <strong>otstr</strong>(x,s)</p>

<p>flash x;
char *s;</p>

<p><strong>Module:</strong>  mrio1.c</p>

<p><strong>Description:</strong> Output a big or flash number to the specified string, using as number base the value specified in the initial call to <strong>mirsys</strong>. A flash number will be converted to radix-point representation if the instance variable RPOINT=ON. Otherwise it will be output as a fraction.</p>

<p><strong>Parameters:</strong> A big/flash number <em>x</em> and a character string <em>s</em>. On exit <em>s</em> will contain a representation of <em>x</em>.</p>

<p><strong>Return value:</strong>  Number of output characters.</p>

<p><strong>Restrictions:</strong> The number base specified in <strong>mirsys</strong> must be less than or equal to 256. If not, use <strong>cotstr</strong> instead.</p>

<blockquote>
<p>Note that there is nothing to prevent this routine from overflowing the limits &gt; of the user supplied character array <em>s</em>, causing obscure runtime problems. It &gt; is the programmers responsibility to ensure that <em>s</em> is big enough to contain &gt; the number output to it. Alternatively use the internally declared instance
string <strong>IOBUFF</strong>, which is of size <strong>IOBSIZ</strong>. If this array overflows a
MIRACL error <strong>will</strong> be flagged.</p>
</blockquote>

<h3 id="9-1-45-premult">9.1.45  premult</h3>

<p><strong>Function:</strong>  void <strong>premult</strong>(x,n,z)</p>

<p>int n
big x,z;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Multiplies a big number by an integer</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>z</em>, and an integer <em>n</em>.</p>

<p>On exit <em>z=n.x</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None  </p>

<h3 id="9-1-46-putdig">9.1.46  putdig</h3>

<p><strong>Function:</strong>  void <strong>putdig</strong>(n,x,i)</p>

<p>big x;
int i,n;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Set a digit of a big number to a given value</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>, a digit number <em>i</em>, and its new value <em>n</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The digit indicated must exist.</p>

<h3 id="9-1-47-remain">9.1.47  remain</h3>

<p><strong>Function:</strong>  int <strong>remain</strong>(x,n)</p>

<p>big x;
int n;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Finds the integer remainder, when a big number is divided by an integer.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>, and an integer <em>n</em>.</p>

<p><strong>Return value:</strong>  The integer remainder  </p>

<h3 id="9-1-48-set_io_buffer_size">9.1.48  set_io_buffer_size</h3>

<p><strong>Function:</strong>   void set_io_buffer_size(len)</p>

<p>int len;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Sets the size of the input/output buffer. By default this is set to 1024, but programs that need to handle very large numbers may require a larger I/O buffer.</p>

<p><strong>Parameters:</strong>  The size of I/O buffer required.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Destroys the current contents of the I/O buffer</p>

<h3 id="9-1-49-set_user_function">9.1.49  set_user_function</h3>

<p><strong>Function:</strong>  void set_user_function(func)</p>

<p>BOOL (*user)(void);</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Supplies a user-specified function, which is periodically called during some of the more time-consuming MIRACL functions, particularly those involved in modular exponentiation and in finding large prime numbers. The supplied function must take no parameters and return a BOOL value. Normally this should be TRUE. If FALSE then MIRACL will attempt to abort its current operation. In this case the function should continue to return FALSE until control is returned to the calling program. The user-supplied function should normally include only a few instructions, and no loops, otherwise it may adversely impact the speed of MIRACL functions.</p>

<p>Once MIRACL is initialised, this function may be called multiple times with a new supplied function. If no longer required, call with a NULL parameter.</p>

<p><strong>Parameters:</strong>  A pointer to a user-supplied function, or NULL if not required.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/* Windows Message Pump */</span>
    <span class="k">static</span> <span class="n">BOOL</span> <span class="nf">idle</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">MSG</span> <span class="n">msg</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">PM_NOREMOVE</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">message</span><span class="o">!=</span><span class="n">WM_QUIT</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">PM_REMOVE</span><span class="p">))</span>
                <span class="p">{</span> <span class="cm">/* do a Message Pump */</span>
                    <span class="n">TranslateMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
                    <span class="n">DispatchMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="n">set_user_function</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-1-50-size">9.1.50  size *</h3>

<p><strong>Function:</strong>  int <strong>size</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Tries to convert big number to a simple integer. Also useful for testing the sign of big/flash variable as in: if (size(x) &lt; 0) ...</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>.</p>

<p><strong>Return value:</strong>  The value of <em>x</em> as an integer. If this is not possible (because <em>x</em> is too big) it returns the value plus or minus <strong>MR_TOOBIG.</strong></p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-51-subdiv">9.1.51  subdiv</h3>

<p><strong>Function:</strong>  int <strong>subdiv</strong>(x,n,z)</p>

<p>int n;
big x,z;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Divide a big number by an integer.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>z</em>, and an integer <em>n</em>.</p>

<p>On exit <em>z=x/n</em>.</p>

<p><strong>Return value:</strong>  The integer remainder.</p>

<p><strong>Restrictions:</strong>  The value of <em>n</em> must not be zero.</p>

<h3 id="9-1-52-subdivisible">9.1.52  subdivisible</h3>

<p><strong>Function:</strong>  BOOL <strong>subdivisible</strong>(x,n)</p>

<p>big x;
int n;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Tests a big number for divisibility by an integer.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em> and an integer <em>n</em>.</p>

<p><strong>Return value:</strong>  TRUE is <em>n</em> divides <em>x</em> exactly, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  The value of <em>n</em> must not be zero.</p>

<h3 id="9-1-53-subtract">9.1.53  subtract</h3>

<p><strong>Function:</strong>  void <strong>subtract</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrarth0.c</p>

<p><strong>Description:</strong>  Subtracts two big numbers.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=x-y</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-1-54-zero">9.1.54  zero *</h3>

<p><strong>Function:</strong>  void <strong>zero</strong>(x)</p>

<p>flash x;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Sets a big or flash number to zero</p>

<p><strong>Parameters:</strong>  A big or flash number <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h2 id="9-2-advanced-arithmetic-routines">9.2  Advanced Arithmetic Routines</h2>

<h3 id="9-2-1-bigdig">9.2.1  bigdig</h3>

<p><strong>Function:</strong>  void <strong>bigdig</strong>(n,b,x)</p>

<p>int n,b;
big x;</p>

<p><strong>Module:</strong>  mrrand.c</p>

<p><strong>Description:</strong>  Generates a big random number of given length. Uses the built-in simple random number generator initialised by <strong>irand.</strong></p>

<p><strong>Parameters:</strong> A big number <em>x</em> and two integers <em>n</em> and <em>b</em>. On exit <em>x</em> contains a big random number <em>n</em> digits long to base <em>b</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The base <em>b</em> must be printable, that is 2 Â£ <em>b</em> Â£ 256.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This generates a 100 decimal digit random number</span>
    <span class="n">bigdig</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-2-2-bigrand">9.2.2  bigrand</h3>

<p><strong>Function:</strong>  void <strong>bigrand</strong>(w,x)</p>

<p>big w,x;</p>

<p><strong>Module:</strong>  mrrand.c</p>

<p><strong>Description:</strong>  Generates a big random number. Uses the built-in simple random number generator initialised by <strong>irand.</strong></p>

<p><strong>Parameters:</strong>  Two big numbers <em>w</em> and <em>x</em>. On exit <em>x</em> is a big random number in the range <em>0</em><em>Â£x &lt; w</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-3-brick_init">9.2.3  brick_init</h3>

<p><strong>Function:</strong>  BOOL <strong>brick_init</strong>(binst,g,n,w,nb)</p>

<p>brick *binst;
big g,n;
int w,nb;</p>

<p><strong>Module:</strong>  mrbrick.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Comb method for modular exponentiation with precomputation. Internally memory is allocated for 2_<sup>w</sup>_ big numbers which will be precomputed and stored. For bigger <em>w</em> more space is required, but the exponentiation is quicker. Try <em>w</em>=8.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance <em>binst</em>, the fixed generator <em>g</em>, the modulus <em>n</em>, the window size <em>w</em>, and the maximum number of bits to be used in the exponent <em>nb</em>.</p>

<p><strong>Return value:</strong>  TRUE if all went well, FALSE if there was a problem.</p>

<p>Restrictions:  Note: If MR_STATIC is defined in <em>mirdef.h</em>, then the <em>g</em> parameter in this function is replaced by an mr_small * pointer to a precomputed table. In this case the function returns a void.</p>

<h3 id="9-2-4-brick_end">9.2.4  brick_end</h3>

<p><strong>Function:</strong>  void <strong>brick_end</strong>(binst)</p>

<p>brick *binst</p>

<p><strong>Module:</strong>  mrbrick.c</p>

<p><strong>Description:</strong>  Cleans up after an application of the Comb method.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None   </p>

<h3 id="9-2-5-crt">9.2.5  crt</h3>

<p><strong>Function:</strong>  void <strong>crt</strong>(pbc,rem,x)</p>

<p>big_chinese *pbc;
big *rem;
big x;</p>

<p><strong>Module:</strong>  mrcrt.c</p>

<p><strong>Description:</strong> Applies Chinese Remainder Theorem.</p>

<p><strong>Parameters:</strong>  A pointer <em>pbc</em> to the current instance. On exit <em>x</em> contains the big number which yields the given big remainders <em>rem[.]</em> when it is divided by the big moduli specified in a prior call to <strong>crt_init</strong>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The routine <strong>crt_init</strong> must be called first.</p>

<h3 id="9-2-6-crt_end">9.2.6  crt_end</h3>

<p><strong>Function:</strong>  void <strong>crt_end</strong>(pbc)</p>

<p>big_chinese *pbc;</p>

<p><strong>Module:</strong>  mrcrt.c</p>

<p><strong>Description:</strong>  Cleans up after an application of the Chinese Remainder Theorem.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance of the Chinese Remainder Theorem.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-7-crt_init">9.2.7  crt_init</h3>

<p><strong>Function:</strong>  BOOL <strong>crt_init</strong>(pbc,np,m)</p>

<p>big_chinese *pbc;
int np;
big *m;</p>

<p><strong>Module:</strong>  mrcrt.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Chinese Remainder Theorem. Some internal workspace is allocated.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance <em>pbc</em>, the number of co-prime moduli <em>np</em>, and an array of at least two big moduli <em>m[.]</em></p>

<p><strong>Return value:</strong>  TRUE if all went well, FALSE if there was a problem.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-8-egcd">9.2.8  egcd</h3>

<p><strong>Function:</strong>  int <strong>egcd</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrgcd.c</p>

<p><strong>Description:</strong>  Calculates the Greatest Common Divisor of two big numbers.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x, y</em> and <em>z</em>.</p>

<p>On exit <em>z=gcd(x,y)</em></p>

<p><strong>Return value:</strong>  GCD as integer, if possible, otherwise <strong>MR_TOOBIG</strong></p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-9-expb2">9.2.9  expb2</h3>

<p><strong>Function:</strong>  void <strong>expb2</strong>(n,x)</p>

<p>int n;
big x;</p>

<p><strong>Module:</strong>  mrbits.c</p>

<p><strong>Description:</strong>  Calculates 2 to the power of an integer as a big</p>

<p><strong>Parameters:</strong>  An integer <em>n</em>, and a big result <em>x</em>.</p>

<p>On exit <em>x=2<sup>n</sup>.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This calculates and prints out the largest known prime number (on a true 32-</span>
    <span class="c1">//bit computer with lots of memory!)</span>
    <span class="n">expb2</span><span class="p">(</span><span class="mi">1398269</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
    <span class="n">decr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
    <span class="n">mip</span><span class="o">-&gt;</span><span class="n">IOBASE</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
    <span class="n">cotnum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">stdout</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-2-10-expint">9.2.10  expint</h3>

<p><strong>Function:</strong>  void <strong>expint</strong>(b,n,x)</p>

<p>int b,n;
big x;</p>

<p><strong>Module:</strong>  mrarth3.c</p>

<p><strong>Description:</strong>  Calculates an integer to the power of an integer as a big</p>

<p><strong>Parameters:</strong>  An integer <em>b</em>, an integer <em>n</em>, and a big result <em>x</em>.</p>

<p>On exit <em>x=b<sup>n</sup>.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-11-fft_mult">9.2.11  fft_mult</h3>

<p><strong>Function:</strong>  void <strong>fft_mult</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrfast.c</p>

<p><strong>Description:</strong>  Multiplies two big numbers, using the Fast Fourier Method. See [Pollard71].</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x, y</em> and <em>z</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Should only be used on a 32-bit computer when <em>x</em> and <em>y</em> are very large, at least 1000 decimal digits.</p>

<p><strong>Example:</strong></p>

<blockquote>
<p>See <em>mersenne.c</em></p>
</blockquote>

<h3 id="9-2-12-gprime">9.2.12  gprime</h3>

<p><strong>Function:</strong>  void <strong>gprime</strong>(n)</p>

<p>int n;</p>

<p><strong>Module:</strong>  mrprime.c</p>

<p><strong>Description:</strong>  Generates all prime numbers up to a certain limit into the instance array PRIMES, terminated by zero. This array is used internally by the routines <strong>isprime</strong> and <strong>nxprime</strong>.</p>

<p><strong>Parameters:</strong>  A positive integer <em>n</em> indicating the maximum prime number to be generated. If <em>n=0</em> the PRIMES array is deleted.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-13-hamming">9.2.13  hamming</h3>

<p><strong>Function:</strong>  int <strong>hamming</strong>(n)</p>

<p>big n;</p>

<p><strong>Module:</strong>  mrarth1.c</p>

<p><strong>Description:</strong>  Calculates the hamming weight of a big number (in fact the number of 1&#39;s in its binary representation.)</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>.</p>

<p><strong>Return value:</strong>  Hamming weight of  <em>x</em></p>

<h3 id="9-2-14-invers">9.2.14  invers</h3>

<p><strong>Function:</strong>  unsigned int <strong>invers</strong>(x,y)</p>

<p>unsigned int x,y;</p>

<p><strong>Module:</strong>  mrsmall.c</p>

<p><strong>Description:</strong>  Calculates the inverse of an integer modulus a co-prime integer</p>

<p><strong>Parameters:</strong>  An integer <em>x</em> and a co-prime integer <em>y</em>.</p>

<p><strong>Return value:</strong>  <em>x<sup>-1</sup>  mod y</em></p>

<p><strong>Restrictions:</strong>  Result unpredictable if <em>x</em> and <em>y</em> not co-prime  </p>

<h3 id="9-2-15-isprime">9.2.15  isprime</h3>

<p><strong>Function:</strong>  BOOL <strong>isprime</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrprime.c</p>

<p><strong>Description:</strong>  Tests whether or not a big number is prime using a probabilistic primality test. The number is assumed to be prime if it passes this test <strong>NTRY</strong> times, where <strong>NTRY</strong> is an instance variable with a default initialisation in routine <strong>mirsys</strong>.</p>

<blockquote>
<p>NOTE: This routine first test divides <em>x</em> by the list of small primes stored
in the instance array <strong>PRIMES</strong>. The testing of larger primes will be
significantly faster in many cases if this list is increased. See <strong>gprime</strong>.
By default only the small primes less than 1000 are used.</p>
</blockquote>

<p><strong>Parameters:</strong>  A big number <em>x</em>.</p>

<p><strong>Return value:</strong>  Returns the boolean value TRUE if <em>x</em> is (almost certainly) prime, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-16-jac">9.2.16  jac</h3>

<p><strong>Function:</strong>  int <strong>jac</strong>(x,n)</p>

<p>unsigned int x,n;</p>

<p><strong>Module:</strong>  mrsmall.c</p>

<p><strong>Description:</strong>  Calculates the value of the Jacobi symbol. See [Reisel].</p>

<p><strong>Parameters:</strong>  Two unsigned numbers <em>x</em> and <em>n</em></p>

<p><strong>Return value:</strong>  The value of <em>(x/n)</em> as +1 or -1, or 0 if symbol undefined</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-17-jack">9.2.17  jack</h3>

<p><strong>Function:</strong>  int <strong>jack</strong>(x,n)</p>

<p>big x,n;</p>

<p><strong>Module:</strong>  mrjack.c</p>

<p><strong>Description:</strong>  Calculates the value of the Jacobi symbol. See [Reisel].</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>n</em></p>

<p><strong>Return value:</strong>  The value of <em>(x/n)</em> as +1 or -1, or 0 if symbol undefined</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-18-logb2">9.2.18  logb2</h3>

<p><strong>Function:</strong>  int <strong>logb2</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrbits.c</p>

<p><strong>Description:</strong>  Calculates the approximate integer log to the base 2 of a big number (in fact the number of bits in it.)</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>.</p>

<p><strong>Return value:</strong>  Number of bits in <em>x</em></p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-19-lucas">9.2.19  lucas</h3>

<p><strong>Function:</strong>  void <strong>lucas</strong>(x,e,n,vp,v)</p>

<p>big x,e,n,vp,v</p>

<p><strong>Module:</strong>  mrlucas.c</p>

<p><strong>Description:</strong>  Performs Lucas modular exponentiation.  Uses Montgomery arithmetic internally. This function can be speeded up further for particular moduli, by invoking special assembly language routines to implement Montgomery arithmetic. See <strong>powmod</strong>.</p>

<p><strong>Parameters:</strong>  Five big numbers <em>x, e, n, vp</em> and <em>v</em>.</p>

<p>On exit <em>v</em>=V_<sub>e</sub><em>(_x</em>) mod <em>n</em> and <em>vp</em>=V_<sub>e-1</sub><em>(_x</em>) mod <em>n</em> where <em>n</em> is the current Montgomery modulus. Only <em>v</em> is returned if <em>v</em> and <em>vp</em> are not distinct.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The value of <em>n</em> must be odd.</p>

<blockquote>
<p>Note:  The &quot;sister&quot; Lucas function U_<sub>e</sub>(x)_ can, if required,  be calculated as</p>
</blockquote>

<p>U_<sub>e</sub>(x)_ <em>Âº</em> <em>[x._V</em><sub>e</sub>(x)â€“ 2.<em>V</em><sub>e-1</sub>(x)]/(x<sup>2</sup> â€“ 4)_ mod <em>n</em></p>

<h3 id="9-2-20-multi_inverse">9.2.20  multi_inverse</h3>

<p><strong>Function:</strong>  BOOL <strong>multi_inverse</strong>(m,x,n,w)</p>

<p>int m;
big n;
big *x,*w;</p>

<p><strong>Module:</strong>  mrxgcd.c</p>

<p><strong>Description:</strong>  Finds the modular inverses of many numbers simultaneously, exploiting Montgomery&#39;s observation that <em>x</em><sup>-1</sup> <em>= y.(xy)</em><sup>-1</sup><em>,  y</em><sup>-1</sup> <em>= x.(xy)</em><sup>-1</sup>. This will be quicker, as modular inverses are slow to calculate, and this way only one is required.</p>

<p><strong>Parameters:</strong>  The number of inverses required <em>m</em>, an array <em>x</em>[.] of <em>m</em> numbers whose inverses are wanted, the modulus <em>n</em>, and the resulting  array of inverses <em>w</em>[.].</p>

<p><strong>Return value:</strong>  TRUE if successful, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  The parameters <em>x</em> and <em>w</em> must be distinct.</p>

<h3 id="9-2-21-nres">9.2.21  nres</h3>

<p><strong>Function:</strong>  void <strong>nres</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Converts a big number to <em>n-residue</em> form.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>y</em>.</p>

<p>On exit <em>y</em> is the <em>n-residue</em> form of <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong>.</p>

<h3 id="9-2-22-nres_dotprod">9.2.22  nres_dotprod</h3>

<p><strong>Function:</strong>  void <strong>nres_dotprod</strong>(m,x,y,w)</p>

<p>int m;
big x[],y[],w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Finds the dot product of two arrays of <em>n-residues</em>. So-called &quot;lazy&quot; reduction is used, in that the sum of products is only reduced once with respect to theMontgomery modulus. This is quicker â€“nearly twice as fast.</p>

<p><strong>Parameters:</strong>  Two arrays <em>x</em> and <em>y</em> each of <em>m</em> <em>n-residues.</em></p>

<p>On exit <em>w=</em><em>S x<sub>i</sub> y<sub>i</sub>_mod _n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong>.</p>

<h3 id="9-2-23-nres_double_modadd">9.2.23  nres_double_modadd</h3>

<p><strong>Function:</strong>  void <strong>nres_double_modadd</strong>(x,y,w)</p>

<p>big x,y,w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Adds two double length bigs modulo <em>p.R</em>, where <em>R</em> is 2_<sup>n</sup>_ and <em>n</em> is the smallest multiple of the word-length of the underlying MIRACL type, such that <em>R&gt;p</em>. This is required for lazy reduction.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=a+b</em> mod <em>pR</em></p>

<p><strong>Return value:</strong>  None  </p>

<h3 id="9-2-24-nres_double_modsub">9.2.24  nres_double_modsub</h3>

<p><strong>Function:</strong>  void <strong>nres_double_modsub</strong>(x,y,w)</p>

<p>big x,y,w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Subtracts two double length bigs  modulo <em>p.R</em>, where <em>R</em> is 2_<sup>n</sup>_ and <em>n</em> is the smallest multiple of the word-length of the underlying MIRACL type, such that <em>R&gt;p</em>. This is required for lazy reduction.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=a-b</em> mod <em>pR</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-25-nres_lazy">9.2.25  nres_lazy</h3>

<p><strong>Function:</strong>  void <strong>nres_lazy</strong>(a,b,c,d,x,y)</p>

<p>big a,b,c,d,x,y;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Uses the method of lazy reduction combined with Karatsuba&#39;s method to multiply two zzn2 variables. Requires just 3 multiplications and two modular reductions.</p>

<p><strong>Parameters:</strong>   Six big numbers. On exit <em>(x+iy)=(a+ib)(c+id)</em>, where <em>i</em> is imaginary square root of the quadratic non-residue.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-26-nres_lucas">9.2.26  nres_lucas</h3>

<p><strong>Function:</strong>  void <strong>nres_lucas</strong>(x,e,vp,v)</p>

<p>big x,e,vp,v;</p>

<p><strong>Module:</strong>  mrlucas.c</p>

<p><strong>Description:</strong>  Modular Lucas exponentiation of an <em>n-residue</em></p>

<p><strong>Parameters:</strong>  An <em>n-residue</em> <em>x</em>, a big exponent <em>e</em>, and two <em>n-residue</em> outputs <em>vp</em> and <em>v</em>.</p>

<p>On exit <em>v</em>=V_<sub>e</sub><em>(_x</em>) mod <em>n</em> and <em>vp</em>=V_<sub>e-1</sub><em>(_x</em>) mod <em>n</em> where <em>n</em> is the current Montgomery modulus. Only <em>v</em> is returned if <em>v</em> and <em>vp</em> are the same big variable.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the first parameter to <em>n-residue</em> form. Note that the exponent is <strong>not</strong> converted to <em>n-residue</em> form.</p>

<h3 id="9-2-27-nres_modadd">9.2.27  nres_modadd</h3>

<p><strong>Function:</strong>  void <strong>nres_modadd(x,y,z)</strong></p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Modular addition of two <em>n-residues</em></p>

<p><strong>Parameters:</strong>  Three <em>n-residue</em> numbers <em>x</em>, <em>y</em>, and <em>z</em>.</p>

<p>On exit <em>z=x+y mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>prepare_monty.</strong></p>

<h3 id="9-2-28-nres_moddiv">9.2.28  nres_moddiv</h3>

<p><strong>Function:</strong>  int <strong>nres_moddiv</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Modular division of two <em>n-residues</em>.</p>

<p><strong>Parameters:</strong>  Three <em>n-residue</em> numbers <em>x, y</em> and <em>z</em>.</p>

<p>On exit <em>z =x/y mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  GCD of <em>y</em> and <em>n</em> as an integer, if possible, or <strong>MR_TOOBIG</strong>. Should be 1 for a valid result.</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of parameters to <em>n-residue</em> form. Parameters <em>x</em> and <em>y</em> must be distinct.</p>

<h3 id="9-2-29-nres_modmult">9.2.29  nres_modmult</h3>

<p><strong>Function:</strong>  void <strong>nres_modmult</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Modular multiplication of two <em>n-residues</em>. Note that this routine will invoke a KCM Modular Multiplier if <strong>MR_KCM</strong> has been defined in <em>mirdef.h</em> and set to an appropriate size for the current modulus, or a Comba fixed size modular multiplier if <strong>MR_COMBA</strong> is defined as exactly the size of the modulus.</p>

<p><strong>Parameters:</strong>  Three <em>n-residue</em> numbers <em>x</em>, <em>y</em> and <em>z</em></p>

<p>On exit <em>z =xy mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of parameters to <em>n-residue</em> form.  </p>

<h3 id="9-2-30-nres_modsub">9.2.30  nres_modsub</h3>

<p><strong>Function:</strong>  void <strong>nres_modsub(x,y,z)</strong></p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Modular subtraction of two <em>n-residues</em></p>

<p><strong>Parameters:</strong>  Three <em>n-residue</em> numbers <em>x</em>, <em>y</em>, and <em>z</em>.</p>

<p>On exit <em>z=x-y mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>prepare_monty.</strong></p>

<h3 id="9-2-31-nres_multi_inverse">9.2.31  nres_multi_inverse</h3>

<p><strong>Function:</strong>  BOOL <strong>nres_multi_inverse</strong>(m,x,w)</p>

<p>int m;
big *x,*w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Finds the modular inverses of many numbers simultaneously, exploiting Montgomery&#39;s observation that <em>x</em><sup>-1</sup> <em>= y.(xy)</em><sup>-1</sup><em>,  y</em><sup>-1</sup> <em>= x.(xy)</em><sup>-1</sup>. This will be quicker, as modular inverses are slow to calculate, and this way only one is required.</p>

<p><strong>Parameters:</strong>  The number of inverses required <em>m</em>, an array <em>x</em>[.] of <em>m</em> <em>n-residues</em> whose inverses are wanted, and an array of their inverses <em>w</em>[.].</p>

<p><strong>Return value:</strong>  TRUE if successful, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  The parameters <em>x</em> and <em>w</em> must be distinct.</p>

<h3 id="9-2-32-nres_negate">9.2.32  nres_negate</h3>

<p><strong>Function:</strong>  void <strong>nres_negate</strong>(x,w)</p>

<p>big x,w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Modular negation.</p>

<p><strong>Parameters:</strong>  Two <em>n-residue</em> numbers <em>x</em> and <em>w</em>.</p>

<p>On exit <em>w= -x mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>prepare_monty.</strong></p>

<h3 id="9-2-33-nres_powltr">9.2.33  nres_powltr</h3>

<p><strong>Function:</strong>  void <strong>powltr</strong>(x,e,w)</p>

<p>int x;
big e,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Modular exponentiation of an <em>n-residue</em></p>

<p><strong>Parameters:</strong>  An ordinary small integer <em>x</em>, a big number <em>e</em> and an <em>n-residue</em> result <em>w</em>.</p>

<p>On exit <em>w=x<sup>e</sup> mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong>. Note that the small integer <em>x</em> and the exponent are <strong>not</strong> converted to <em>n-residue</em> form.</p>

<h3 id="9-2-34-nres_powmod">9.2.34  nres_powmod</h3>

<p><strong>Function:</strong>  void <strong>nres_powmod</strong>(x,y,z)</p>

<p>big x,y,z;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Modular exponentiation of an <em>n-residue</em>.</p>

<p><strong>Parameters:</strong>  An <em>n-residue</em> number <em>x</em>, a big number <em>y</em> and an <em>n-residue</em> result <em>z</em>. On exit <em>z =x<sup>y</sup> mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the first parameter to <em>n-residue</em> form. Note that the exponent is <strong>not</strong> converted to <em>n-residue</em> form.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">prepare_monty</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">nres</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="cm">/* convert to _n-residue_ form */</span>
    <span class="n">nres_powmod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
    <span class="n">redc</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">);</span> <span class="cm">/* convert back to normal form */</span>
</code></pre></div>
<h3 id="9-2-35-nres_powmod2">9.2.35  nres_powmod2</h3>

<p><strong>Function:</strong>  void <strong>nres_powmod2</strong>(x,y,a,b,w)</p>

<p>big x,y,a,b,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Calculate the product of two modular exponentiations involving <em>n-residues</em>.</p>

<p><strong>Parameters:</strong>  Three <em>n-residue</em> numbers <em>x</em>, <em>a</em> and <em>w</em>, and two big integers <em>y</em> and <em>b</em>.</p>

<p>On exit <em>w = x<sup>y</sup> .a<sup>b</sup> mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the appropriate parameters to <em>n-residue</em> form. Note that the exponents are <strong>not</strong> converted to <em>n-residue</em> form.</p>

<h3 id="9-2-36-nres_powmodn">9.2.36  nres_powmodn</h3>

<p><strong>Function:</strong>  void <strong>nres_powmodn</strong>(m,x,y,w)</p>

<p>int m;
big <strong><em>x,</em></strong>y,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Calculate the product of <em>m</em> modular exponentiations involving <em>n-residues</em>. Extra memory is allocated internally by this function.</p>

<p><strong>Parameters:</strong>  The integer <em>m,</em> an array of <em>m n-residue</em> numbers <em>x</em>, an array of <em>m</em> big integers <em>y</em>, and an <em>n-residue</em> <em>w</em>.</p>

<p>On exit <em>w = x[0]<sup>y[0]</sup> . x[1]<sup>y[1]</sup> â€¦ . x[m-1]<sup>y[m-1]</sup> mod n</em>, where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the appropriate parameters to <em>n-residue</em> form. Note that the exponents are <strong>not</strong> converted to <em>n-residue</em> form.</p>

<h3 id="9-2-37-nres_premult">9.2.37  nres_premult</h3>

<p><strong>Function:</strong>  void <strong>nres_premult</strong>(x,k,w)</p>

<p>int k;
big x,w;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Multiplies an <em>n-residue</em> by a small integer.</p>

<p><strong>Parameters:</strong>  Two <em>n-residues</em> <em>x</em> and <em>w</em>, and a small integer <em>k</em>.</p>

<p>On exit <em>w = kx mod n,</em> where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the first parameter to <em>n-residue</em> form. Note that the small integer is <strong>not</strong> converted to <em>n-residue</em> form.</p>

<h3 id="9-2-38-nres_sqroot">9.2.38  nres_sqroot</h3>

<p><strong>Function:</strong>  BOOL <strong>nres_sqroot</strong>(x,w)</p>

<p>big x,w;</p>

<p><strong>Module:</strong>  mrsroot.c</p>

<p><strong>Description:</strong>  Calculates the square root of an <em>n-residue</em> mod a prime modulus</p>

<p><strong>Parameters:</strong>  Two <em>n-residues</em> <em>x</em> and <em>w</em>.</p>

<p>On exit <em>w=</em><em>Ã–x mod n</em> where <em>n</em> is the currentMontgomery modulus.</p>

<p><strong>Return value:</strong>  TRUE if the square root exists, otherwise FALSE</p>

<p><strong>Restrictions:</strong>  Must be preceded by call to <strong>prepare_monty</strong> and conversion of the first parameter to <em>n-residue</em> form.</p>

<h3 id="9-2-39-nroot">9.2.39  nroot</h3>

<p><strong>Function:</strong>  BOOL <strong>nroot</strong>(x,n,z)</p>

<p>big x,z;
int n;</p>

<p><strong>Module:</strong>  mrarth3.c</p>

<p><strong>Description:</strong>  Extracts lower approximation to a root of a big number.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>z</em>, and an integer <em>n</em>.</p>

<p>On exit <em>z=</em> Ã«<em>x<sup>1/n</sup></em> Ã».</p>

<p><strong>Return value:</strong>  Returns the boolean value TRUE if the root found is exact, otherwise returns FALSE.</p>

<p><strong>Restrictions:</strong>  The value of <em>n</em> must be positive. If <em>x</em> is negative, then <em>n</em> must be odd.</p>

<h3 id="9-2-40-nxprime">9.2.40  nxprime</h3>

<p><strong>Function:</strong>  BOOL <strong>nxprime</strong>(w,x)</p>

<p>big w,x;</p>

<p><strong>Module:</strong>  mrprime.c</p>

<p><strong>Description:</strong>  Find next prime number.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>w</em> and <em>x</em>.</p>

<p>On exit <em>x</em> contains the next prime number greater than <em>w</em>.</p>

<p><strong>Return value:</strong>  TRUE if successful, FALSE otherwise.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-41-nxsafeprime">9.2.41  nxsafeprime</h3>

<p><strong>Function:</strong>  BOOL n*<em>xsafeprime</em>*(type,subset,w,p)</p>

<p>int type,subset;
big w,p;</p>

<p><strong>Module:</strong>  mrprime.c</p>

<p><strong>Description:</strong>  Find next <em>safe</em> prime number greater than <em>w</em>. A <em>safe</em> prime number <em>p</em> is defined here to be one for which <em>q=</em>(<em>p</em>-1)/2 (<em>type</em>=0) or <em>q=</em>(<em>p</em>+1)/2 (<em>type=_1</em>)_ is also prime.</p>

<p><strong>Parameters:</strong>  The integer parameter <em>type</em> determines the type of safe prime as above. If the parameter <em>subset</em>=1, then the search is restricted so that the value of the prime <em>q</em> is congruent to 1 mod 4. If <em>subset=_3, then the search is restricted so that the value of _q</em> is congruent to 3 mod 4. If <em>subset</em>=0 then there is no condition on <em>q</em>: it can be either 1 or 3 mod 4.</p>

<p><strong>Return value:</strong>  TRUE if successful, FALSE otherwise</p>

<h3 id="9-2-42-pow_brick">9.2.42  pow_brick</h3>

<p><strong>Function:</strong>  void <strong>pow_brick</strong>(binst,e,w)</p>

<p>brick *binst;
big e,w;</p>

<p><strong>Module:</strong>  mrbrick.c</p>

<p><strong>Description:</strong>  Carries out a modular exponentiation, using the precomputed values stored in the <em>brick</em> structure.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance, a big exponent <em>e</em> and a big number <em>w</em>. On exit <em>w=g<sup>e</sup> mod n</em>, where <em>g</em> and <em>n</em> are specified in the initial call to <strong>brick_init.</strong></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>brick_init</strong>.</p>

<h3 id="9-2-43-power">9.2.43  power</h3>

<p><strong>Function:</strong>  void <strong>power</strong>(x,n,z,w)</p>

<p>long n;
big x,z,w;</p>

<p><strong>Module:</strong>  mrarth3.c</p>

<p><strong>Description:</strong>  Raise a big number to an integer power.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>z</em>, and an integer <em>n</em>. On exit <em>w=x<sup>n</sup></em> . If <em>w</em> and <em>z</em> are distinct, then <em>w=x<sup>n</sup>  mod z</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The value of <em>n</em> must be positive</p>

<h3 id="9-2-44-powltr">9.2.44  powltr</h3>

<p><strong>Function:</strong>  int <strong>powltr</strong>(x,y,z,w)</p>

<p>int x;
big y,z,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Raise an <em>int</em> to the power of a big number modulus another big number. Uses Left-to-Right binary method, and will be somewhat faster than <strong>powmod</strong> for small <em>x</em>. Uses Montgomery arithmetic internally if the modulus <em>z</em> is odd.</p>

<p><strong>Parameters:</strong>  An integer <em>x</em> and three bigs <em>y</em>, <em>z</em> and <em>w</em>.</p>

<p>On exit <em>w=x<sup>y</sup> mod z</em></p>

<p><strong>Return value:</strong>  The result expressed as an integer, if possible. Otherwise the value <strong>MR_TOOBIG</strong>.</p>

<p><strong>Restrictions:</strong>  The value of <em>y</em> must be positive. The parameters <em>w</em> and <em>z</em> must be distinct.</p>

<h3 id="9-2-45-powmod">9.2.45  powmod</h3>

<p><strong>Function:</strong>  void <strong>powmod</strong>(x,y,z,w)</p>

<p>big x,y,z,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Raise a big number to a big power modulus another big. Uses a sophisticated 5-bit sliding window technique, which is close to optimal for popular modulus sizes (such as 512 or 1024 bits). Uses Montgomery arithmetic internally if the modulus <em>z</em> is odd.</p>

<p>This function can be speeded up further for particular moduli, by invoking special assembly language routines (if your compiler allows it). A KCM Modular Multiplier will be automatically invoked if <strong>MR_KCM</strong> has been defined in <em>mirdef.h</em> and has been set to an appropriate size. Alternatively a Comba modular multiplier will be used if <strong>MR_COMBA</strong> is so defined, and the modulus is of the specified size. Experimental coprocessor code will be called if <strong>MR_PENTIUM</strong> is defined. Only one of these conditionals should be defined.</p>

<p><strong>Parameters:</strong>  Four big numbers <em>x, y, z</em> and <em>w</em>.</p>

<p>On exit <em>w=x<sup>y</sup> mod z</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The value of <em>y</em> must be positive. The parameters <em>w</em> and <em>z</em> must be distinct.</p>

<h3 id="9-2-46-powmod2">9.2.46  powmod2</h3>

<p><strong>Function:</strong>  void <strong>powmod2</strong>(a,b,c,d,z,w)</p>

<p>big a,b,c,d,z,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Calculate the product of two modular exponentiations. This is quicker than doing two separate exponentiations, and is useful for certain Cryptographic protocols. Uses 2-bit sliding window.</p>

<p><strong>Parameters:</strong>  Six big numbers <em>a ,b, c, d, z</em> and <em>w</em>.</p>

<p>On exit <em>w=a<sup>b</sup>.c<sup>d</sup> mod z</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The values of <em>b</em> and <em>d</em> must be positive. The parameters <em>w</em> and <em>z</em> must be distinct. The modulus <em>z</em> must be odd.</p>

<p><strong>Example:</strong></p>

<blockquote>
<p>See <em>dssver.c</em></p>
</blockquote>

<h3 id="9-2-47-powmodn">9.2.47  powmodn</h3>

<p><strong>Function:</strong>  void <strong>powmodn</strong>(m,a,b,z,w)</p>

<p>int m;
big <strong><em>a,</em></strong>b,z,w;</p>

<p><strong>Module:</strong>  mrpower.c</p>

<p><strong>Description:</strong>  Calculate the product of <em>m</em> modular exponentiations. This is quicker than doing <em>m</em> separate exponentiations, and is useful for certain Cryptographic protocols. Extra memory is allocated internally for this function</p>

<p><strong>Parameters:</strong>  An integer <em>m</em>, two big number arrays <em>a[]</em> and <em>b[]</em>, and two big numbers _ z_ and <em>w</em>. On exit <em>w=a[0]<sup>b[0]</sup>.a[1]<sup>b[1]</sup> â€¦Â  . a[m-1]<sup>b[m-1]</sup> mod z</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The values of <em>b[]</em> must be positive. The parameters <em>w</em> and <em>z</em> must be distinct. The modulus <em>z</em> must be odd. The underlying number base must be a power of 2.</p>

<h3 id="9-2-48-prepare_monty">9.2.48  prepare_monty</h3>

<p><strong>Function:</strong>  void <strong><em>prepare</em>monty_</strong>(n)</p>

<p>big n;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Prepares a Montgomery Modulus for use. Each call to this function replaces the previous modulus (if any).</p>

<p><strong>Parameters:</strong>  A big number <em>n</em>, which is to be theMontgomery modulus.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The parameter <em>n</em> must be positive and odd. Allocated memory is freed when the current instance of MIRACL is terminated by a call to <strong>mirexit</strong>.</p>

<h3 id="9-2-49-redc">9.2.49  redc</h3>

<p><strong>Function:</strong>  void <strong>redc</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrmonty.c</p>

<p><strong>Description:</strong>  Converts an <em>n-residue</em> back to normal form.</p>

<p><strong>Parameters:</strong>  Two big numbers <em>x</em> and <em>y</em>.</p>

<p>On exit <em>y</em> is the normal form of the <em>n-residue</em> <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Use must be preceded by call to <strong>prepare_monty</strong>.</p>

<h3 id="9-2-50-scrt">9.2.50  scrt</h3>

<p><strong>Function:</strong>  void <strong>scrt</strong>(psc,rem,x)</p>

<p>small_chinese *psc;
int *rem;
big x;</p>

<p><strong>Module</strong>:  mrscrt.c</p>

<p><strong>Description:</strong>  Applies Chinese Remainder Theorem (for small prime moduli).</p>

<p><strong>Parameters:</strong>  A pointer <em>psc</em> to the current instance of the Chinese Remainder Theorem. On exit <em>x</em> contains the big number which yields the given integer remainders <em>rem[.]</em> when it is divided by the integer moduli specified in a prior call to <strong>scrt_init</strong>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The routine <strong>scrt_init</strong> must be called first.</p>

<h3 id="9-2-51-scrt_end">9.2.51  scrt_end</h3>

<p><strong>Function:</strong>  void <strong>scrt_end</strong>(psc)</p>

<p>small_chinese *psc;</p>

<p><strong>Module:</strong>  mrscrt.c</p>

<p><strong>Description:</strong>  Cleans up after an application of the Chinese Remainder Theorem.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance of the Chinese Remainder Theorem..</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-52-scrt_initcopy">9.2.52  scrt_initcopy</h3>

<p><strong>Function:</strong>  BOOL <strong>scrt_init</strong>(psc,np,m)</p>

<p>small_chinese *psc;
int np;
int *m;</p>

<p><strong>Module:</strong>  mrscrt.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Chinese Remainder Theorem. Some internal workspace is allocated.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance <em>psc</em>. The number of co-prime moduli <em>np</em>, and an array of at least two integer moduli <em>m[.].</em></p>

<p><strong>Return value:</strong>  TRUE if all went well, FALSE if there was a problem.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-53-sftbit">9.2.53  sftbit</h3>

<p><strong>Function:</strong>  void <strong>sftbit</strong>(x,n,z)</p>

<p>big x,z;
int n;</p>

<p><strong>Module:</strong>  mrbits.c</p>

<p><strong>Description:</strong>  Shifts a big integer left or right by a number of bits.</p>

<p><strong>Parameters:</strong>  The big parameter <em>x</em> is shifted by <em>n</em> bits, to give <em>z</em>. Positive <em>n</em> shifts to the left, negative to the right.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-54-smul">9.2.54  smul</h3>

<p><strong>Function:</strong>  unsigned int <strong>smul</strong>(x,y,z)</p>

<p>Unsigned int x,y,z;</p>

<p><strong>Module:</strong>  mrsmall.c</p>

<p><strong>Description:</strong>  Multiplies two integers mod a third</p>

<p><strong>Parameters:</strong>  Integers <em>x, y</em> and <em>z</em></p>

<p><strong>Return value:</strong>  <em>x.y mod z</em></p>

<h3 id="9-2-55-spmd">9.2.55  spmd</h3>

<p><strong>Function:</strong>  unsigned int <strong>spmd</strong>(x,y,z)</p>

<p>Unsigned int x,y,z;</p>

<p><strong>Module:</strong>  mrsmall.c</p>

<p><strong>Description:</strong>  Raises an integer to an integer power modulus a third</p>

<p><strong>Parameters:</strong>  Integers <em>x, y</em>, and <em>z</em></p>

<p><strong>Return value:</strong>  <em>x<sup>y</sup> mod z</em></p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-2-56-sqrmp">9.2.56  sqrmp</h3>

<p><strong>Function:</strong>  unsigned int <strong>sqrmp</strong>(x,p)</p>

<p>Unsigned int x,p;</p>

<p><strong>Module:</strong>  mrsmall.c</p>

<p><strong>Description:</strong>  Calculates the square root of an integer mod an integer prime number</p>

<p><strong>Parameters:</strong>  An integer <em>x</em> and a prime number <em>p</em></p>

<p><strong>Return value:</strong> <em>Ã–x mod p</em>, or 0 if root does not exist</p>

<p><strong>Restrictions:</strong>  Return value unpredictable if <em>p</em> is not prime  </p>

<h3 id="9-2-57-sqroot">9.2.57  sqroot</h3>

<p><strong>Function:</strong>  BOOL <strong>sqroot</strong>(x,p,w)</p>

<p>big x,p;</p>

<p><strong>Module:</strong>  mrsroot.c</p>

<p><strong>Description:</strong>  Calculates the square root of a big integer mod a big integer prime.</p>

<p><strong>Parameters:</strong>  Two big integers <em>x</em> and <em>w</em>, and a big prime number <em>p</em>.</p>

<p>On exit <em>w=</em>Ã–x mod p_ if the square root exists, otherwise <em>w=0</em>. Note that the &quot;other&quot; square root may be found by subtracting <em>w</em> from <em>p</em>.</p>

<p><strong>Return value:</strong>  TRUE if the square root exists, FALSE otherwise.</p>

<p><strong>Restrictions:</strong>  The number <em>p</em> must be prime.</p>

<h3 id="9-2-58-trial_division">9.2.58  trial_division</h3>

<p><strong>Function:</strong>  int <strong>trial_division</strong>(x,y)</p>

<p>big x,y;</p>

<p><strong>Module:</strong>  mrprime.c</p>

<p><strong>Description:</strong>  Dual purpose trial division routine. If <em>x</em> and <em>y</em> are the same big variable then trial division by the small prime numbers in the instance array <strong>PRIMES</strong> is attempted to determine the primality status of the big number. If <em>x</em> and <em>y</em> are distinct then, after trial division, the unfactored part of <em>x</em> is returned in <em>y</em>.</p>

<p><strong>Parameters:</strong>  Two big integers <em>x</em> and <em>y</em>.</p>

<p><strong>Return value:</strong>  If <em>x</em> and <em>y</em> are the same, then a return value of 0 means that the big number is definitely not prime, a return value of 1 means that it definitely is prime, while a return value of 2 means that it is possibly prime (and that perhaps further testing should be carried out).</p>

<p>If <em>x</em> and <em>y</em> are distinct, then a return value of 1 means that <em>x</em> is <em>smooth</em>, that is it is completely factored by trial division (and <em>y</em> is the largest prime factor). A return value of 2 means that the unfactored part <em>y</em> is possibly prime.   </p>

<h3 id="9-2-59-xgcd">9.2.59  xgcd</h3>

<p><strong>Function:</strong>  int <strong>xgcd</strong>(x,y,xd,yd,z)</p>

<p>big x,y,xd,yd,z;</p>

<p><strong>Module:</strong>  mrxgcd.c</p>

<p><strong>Description:</strong>  Calculates extended Greatest Common Divisor of two big numbers. Can be used to calculate modular inverses. Note that this routine is much slower than a <strong>mad</strong> operation on numbers of similar size.</p>

<p><strong>Parameters:</strong>  Five big numbers <em>x,y,xd,yd</em> and <em>z</em>.</p>

<p>On exit <em>z=gcd(x,y)=x.xd+y.yd</em></p>

<p><strong>Return value:</strong>  GCD as integer, if possible, otherwise <strong>MR_TOOBIG</strong></p>

<p><strong>Restrictions:</strong>  If <em>xd</em> and <em>yd</em> are not distinct, only <em>xd</em> is returned. The GCD is only returned if <em>z</em> distinct from both <em>xd</em> and <em>yd</em>.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* _x = 1/x mod_ _p_  (_p_ is prime) */</span>
</code></pre></div>
<h3 id="9-2-60-zzn2_add">9.2.60  zzn2_add</h3>

<p><strong>Function:</strong>  void <strong>zzn2_add</strong>(x,y,z)</p>

<p>zzn2 *x,*y,*z;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Adds two zzn2 variables.</p>

<p><strong>Parameters:</strong>  Three zzn2 variables <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=x+y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-61-zzn2_compare">9.2.61  zzn2_compare</h3>

<p><strong>Function:</strong>  BOOL <strong>zzn2_compare</strong>(x,y)</p>

<p>zzn2 *x,*y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Compares two zzn2 variables for equality</p>

<p><strong>arameters:</strong>  Two zzn2 values <em>x</em> and <em>y</em></p>

<p><strong>Return value:</strong>   TRUE if <em>x=y</em>, otherwise FALSE</p>

<h3 id="9-2-62-zzn2_conj">9.2.62  zzn2_conj</h3>

<p><strong>Function:</strong>  void <strong>zzn2_conj</strong>(x,y)</p>

<p>zzn2 *x,*y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Finds the conjugate of a zzn2</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>y</em>. If <em>x=a+ib</em>, then on exit <em>y=a-ib</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-63-zzn2_copy">9.2.63  zzn2_copy</h3>

<p><strong>Function:</strong>   void <strong>zzn2_copy</strong>(x,y)</p>

<p>zzn2 *x,*y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Copies one zzn2 to another</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>y</em>. On exit <em>y=x</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-64-zzn2_from_big">9.2.64  zzn2_from_big</h3>

<p><strong>Function:</strong>  void <strong>zzn2_from_big</strong>(a,x)</p>

<p>big a;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Creates a zzn2 from a big integer. This is converted internally into <em>n-residue</em> format.</p>

<p><strong>Parameters:</strong>   A big integer <em>a</em> and a zzn2 <em>x</em>. On exit <em>x=a</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-65-zzn2_from_bigs">9.2.65  zzn2_from_bigs</h3>

<p><strong>Function:</strong>  void <strong>zzn2_from_bigs</strong>(a,b,x)</p>

<p>big a,b;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Creates a zzn2 from two big integers. These are converted internally into <em>n-residue</em> format.</p>

<p><strong>Parameters:</strong>   Two big integers <em>a</em> and <em>b</em> and a zzn2 <em>x</em>. On exit <em>x=a+ib</em></p>

<p><strong>Return value:</strong>  None  </p>

<h3 id="9-2-66-zzn2_from_int">9.2.66  zzn2_from_int</h3>

<p>Function:  void <strong>zzn2_from_int</strong>(a,x)</p>

<p>int a;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Converts an integer to zzn2 format</p>

<p><strong>Parameters:</strong>  An integer <em>a</em> and a zzn2 <em>x</em>. On exit <em>x=a</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-67-zzn2_from_ints">9.2.67  zzn2_from_ints</h3>

<p><strong>Function:</strong>  void <strong>zzn2_from_ints</strong>(a,b,x)</p>

<p>int a,b;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Creates a zzn2 from two integers</p>

<p><strong>Parameters:</strong>   Two integers <em>a</em> and <em>b</em> and a zzn2 <em>x</em>. On exit <em>x=a+ib</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-68-zzn2_from_zzn">9.2.68  zzn2_from_zzn</h3>

<p><strong>Function:</strong>  void <strong>zzn2_from_zzn</strong>(a,x)</p>

<p>big a;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Creates a zzn2 from a big already in <em>n-residue</em> format.</p>

<p><strong>Parameters:</strong>   A big <em>a</em> and a zzn2 <em>x</em>. On exit <em>x=a</em></p>

<p><strong>Return value:</strong>  None  </p>

<h3 id="9-2-69-zzn2_from_zzns">9.2.69  zzn2_from_zzns</h3>

<p><strong>Function:</strong>  void <strong>zzn2_from_zzns</strong>(a,b,x)</p>

<p>big a,b;
zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Creates a zzn2 from two bigs already in <em>n-residue</em> format.</p>

<p><strong>Parameters:</strong>   Two bigs <em>a</em> and <em>b</em> and a zzn2 <em>x</em>. On exit <em>x=a+ib</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-70-zzn2_imul">9.2.70  zzn2_imul</h3>

<p><strong>Function:</strong>  void <strong>zzn2_simul</strong>(x,y,z)</p>

<p>zzn2 *x,*z;
int y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Multiplies a zzn2 variable by an integer.</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>z</em>, and an integer <em>y</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-71-zzn2_inv">9.2.71  zzn2_inv</h3>

<p><strong>Function:</strong>  BOOL <strong>zzn2_inv</strong>(x)</p>

<p>zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  In-place inversion of a zzn2 variable</p>

<p><strong>Parameters:</strong>  A single zzn2 variable <em>x</em>. On exit <em>x=1/x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-72-zzn2_isunity">9.2.72  zzn2_isunity</h3>

<p><strong>Function:</strong>  BOOL <strong>zzn2_isunity</strong>(x)</p>

<p>zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Tests a zzn2 value for equality to one</p>

<p><strong>Parameters:</strong>  A single zzn2 variable <em>x</em></p>

<p><strong>Return value:</strong>  TRUE if <em>x</em> is one, otherwise FALSE.</p>

<h3 id="9-2-73-zzn2_iszero">9.2.73  zzn2_iszero</h3>

<p><strong>Function:</strong>  BOOL <strong>zzn2_iszero</strong>(x)</p>

<p>zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Tests a zzn2 variable for equality to zero</p>

<p><strong>Parameters:</strong>  A single zzn2 value <em>x</em></p>

<p><strong>Return value:</strong>  TRUE if <em>x</em> is zero, otherwise FALSE.</p>

<h3 id="9-2-74-zzn2_mul">9.2.74  zzn2_mul</h3>

<p><strong>Function:</strong>  void <strong>zzn2_mul</strong>(x,y,z)</p>

<p>zzn2 *x,*y,*z;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Multiplies two zzn2 variables. If <em>x</em> and <em>y</em> are the same variable, a faster squaring method is used.</p>

<p><strong>Parameters:</strong>  Three zzn2 variables <em>x, y</em> and <em>z</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-75-zzn2_negate">9.2.75  zzn2_negate</h3>

<p><strong>Function:</strong>  void <strong>zzn2_negate</strong>(x,y)</p>

<p>zzn2 *x,*y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Negate a zzn2.</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>y</em>. On exit <em>y=-x</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-76-zzn2_sadd">9.2.76  zzn2_sadd</h3>

<p><strong>Function:</strong>  void <strong>zzn2_sadd</strong>(x,y,z)</p>

<p>zzn2 *x,*z;
big y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Adds a big in <em>n-residue</em> format to a zzn2 .</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>z</em>, and a big variable <em>y</em>. On exit <em>z=x+y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-77-zzn2_smul">9.2.77  zzn2_smul</h3>

<p><strong>Function:</strong>  void <strong>zzn2_smul</strong>(x,y,z)</p>

<p>zzn2 *x,*z;
big y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Multiplies a zzn2 variable by a big in <em>n-residue</em>.</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>z</em>, and a big variable <em>y</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-78-zzn2_ssub">9.2.78  zzn2_ssub</h3>

<p><strong>Function:</strong>  void <strong>zzn2_ssub</strong>(x,y,z)</p>

<p>zzn2 *x,*z;
big y;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Subtracts a big in <em>n-residue</em> format from a zzn2 .</p>

<p><strong>Parameters:</strong>  Two zzn2 variables <em>x</em> and <em>z</em>, and a big variable <em>y</em>. On exit <em>z=x-y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-79-zzn2_sub">9.2.79  zzn2_sub</h3>

<p><strong>Function:</strong>  void <strong>zzn2_sub</strong>(x,y,z)</p>

<p>zzn2 *x,*y,*z;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>   Subtracts two zzn2 variables .</p>

<p><strong>Parameters:</strong>  Three zzn2 variables <em>x, y</em> and <em>z</em>. On exit <em>z=x-y</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-2-80-zzn2_timesi">9.2.80  zzn2_timesi</h3>

<p><strong>Function:</strong>  BOOL <strong>zzn2_timesi</strong>(x)</p>

<p>zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong> In-place multiplication of a zzn2 by <em>i,</em> the imaginary square root of the quadratic non-residue.</p>

<p><strong>Parameters:</strong>  A single zzn2 variable <em>x</em>. If <em>x=a+ib</em> then on exit <em>x=i</em><em><sup>2</sup>b+ia</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-2-81-zzn2_zero">9.2.81  zzn2_zero</h3>

<p><strong>Function:</strong>  void <strong>zzn2_iszero</strong>(x)</p>

<p>zzn2 *x;</p>

<p><strong>Module:</strong>  mrzzn2.c</p>

<p><strong>Description:</strong>  Sets a zzn2 variable to zero</p>

<p><strong>Parameters:</strong>  A single zzn2 variable <em>x</em>. On exit <em>x=0</em></p>

<p><strong>Return value:</strong>  None</p>

<h2 id="9-3-elliptic-curve-routines">9.3 Elliptic curve routines</h2>

<h3 id="9-3-1-ebrick_init">9.3.1  ebrick_init</h3>

<p><strong>Function:</strong>  BOOL <strong>ebrick_init</strong>(binst,x,y,a,b,n,w,nb)</p>

<p>ebrick *binst;
big x,y;
big a,b,n;
int w,nb;</p>

<p><strong>Module:</strong>  mrebrick.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Comb method for GF(<em>p</em>) elliptic curve multiplication with precomputation. Internally memory is allocated for 2_<sup>w</sup>_ elliptic curve points which will be precomputed and stored. For bigger <em>w</em> more space is required, but the exponentiation is quicker. Try <em>w</em>=8.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance <em>binst</em>, the fixed point <em>G=</em>(<em>x,y</em>) on the curve  <em>y<sup>2</sup> =x<sup>3</sup> + ax + b</em>, the modulus <em>n</em>, and the maximum number of bits to be used in the exponent <em>nb</em>.</p>

<p><strong>Return value:</strong>  TRUE if all went well, FALSE if there was a problem.</p>

<p><strong>Restrictions:</strong>  Note: If MR_STATIC is defined in <em>mirdef.h</em>, then the <em>x</em> and <em>y</em> parameters in this function are replaced by a single mr_small * pointer to a precomputed table. In this case the function returns a void.</p>

<h3 id="9-3-2-ebrick2_init">9.3.2  ebrick2_init</h3>

<p><strong>Function:</strong>  BOOL <strong>ebrick2_init</strong>(binst,x,y,A,B,m,a,b,c,nb)</p>

<p>ebrick2 *binst;
big x,y;
big A,B;
int m,a,b,c,nb;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Comb method for GF(2_<sup>m</sup><em>) elliptic curve multiplication with precomputation. The field is defined with respect to the trinomial basis _t<sup>m</sup>+t<sup>a</sup>+1</em> or the pentanomial basis <em>t<sup>m</sup>+t<sup>a</sup>+t<sup>b</sup>+t<sup>c</sup>+1</em>. Internally memory is allocated for 2_<sup>w</sup>_ elliptic curve points which will be precomputed and stored. For bigger <em>w</em> more space is required, but the exponentiation is quicker. Try <em>w</em>=8.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance <em>binst</em>, the fixed point <em>G=</em>(<em>x,y</em>) on the curve  <em>y<sup>2</sup> + xy = x<sup>3</sup> + Ax<sup>2</sup> + B</em>, the field parameters <em>m, a, b, c</em>, and the maximum number of bits to be used in the exponent <em>nb</em>. Set <em>b</em> = 0 for a trinomial basis.</p>

<p><strong>Return value:</strong>  TRUE if all went well, FALSE if there was a problem.</p>

<p><strong>Restrictions:</strong>  Note: If MR_STATIC is defined in <em>mirdef.h</em>, then the <em>x</em> and <em>y</em> parameters in this function are replaced by a single mr_small * pointer to a precomputed table. In this case the function returns a void.</p>

<h3 id="9-3-3-ebrick_end">9.3.3  ebrick_end</h3>

<p><strong>Function:</strong>  void <strong>ebrick_end</strong>(binst)</p>

<p>ebrick *binst</p>

<p><strong>Module:</strong>  mrebrick.c</p>

<p><strong>Description:</strong>  Cleans up after an application of the Comb for GF(<em>p</em>) elliptic curves</p>

<p><strong>Parameters:</strong>  A pointer to the current instance</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-4-ebrick2_end">9.3.4  ebrick2_end</h3>

<p><strong>Function:</strong>  void <strong>ebrick2_end</strong>(binst)</p>

<p>ebrick2 *binst</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Cleans up after an application of the Comb method for GF(2_<sup>m</sup>_) elliptic curves.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-5-ecurve_add">9.3.5  ecurve_add</h3>

<p><strong>Function:</strong>  void <strong>ecurve_add</strong>(p,pa)</p>

<p>epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Adds two points on a GF(<em>p)</em> elliptic curve using the special rule for addition. Note that if <em>pa=p</em>, then a different duplication rule is used. Addition is quicker if <em>p</em> is normalised.</p>

<p><strong>Parameters:</strong>  Two points on the current active curve_, pa_ and <em>p</em>. On exit <em>pa=pa+p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The input points must actually be on the current active curve.  </p>

<h3 id="9-3-6-ecurve2_add">9.3.6  ecurve2_add</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_add</strong>(p,pa)</p>

<p>epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Adds two points on a GF(2_<sup>m</sup><em>) elliptic curve using the special rule for addition. Note that if _pa=p</em>, then a different duplication rule is used. Addition is quicker if <em>p</em> is normalised.</p>

<p><strong>Parameters:</strong>  Two points on the current active curve_, pa_ and <em>p</em>. On exit <em>pa=pa+p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The input points must actually be on the current active curve.</p>

<h3 id="9-3-7-ecurve_init">9.3.7  ecurve_init</h3>

<p><strong>Function:</strong>  void <strong>ecurve_init</strong>(A,B,p,type)</p>

<p>big A,B,p;
int type;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Initialises the internal parameters of the current active GF(<em>p</em>) elliptic curve. The curve is assumed to be of the form  <em>y<sup>2</sup> =x<sup>3</sup> + Ax + B mod p</em>, the so-called Weierstrass model. This routine can be called subsequently with the parameters of a different curve.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>A</em>, <em>B</em> and <em>p</em>. The <em>type</em> parameter must be either <strong>MR_PROJECTIVE</strong> or ** MR_AFFINE**, and specifies whether projective or affine co-ordinates should be used internally. Normally the former is faster.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Allocated memory will be freed when the current instance of MIRACL is terminated by a call to <strong>mirexit</strong>. However only one elliptic curve, GF(<em>p</em>) or GF(2_<sup>m</sup><em>) may be active within a single MIRACL instance. In addition, a call to a function like <strong>powmod</strong> will overwrite the stored modulus. This can be restored by a repeat call to **ecurve</em>init**</p>

<h3 id="9-3-8-ecurve2_init">9.3.8  ecurve2_init</h3>

<p>Function:  BOOL <strong>ecurve2_init</strong>(m,a,b,c,A,B,check,type)</p>

<p>big A,B;
int m,a,b,c,type;
BOOL check;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Initialises the internal parameters of the current active elliptic curve. The curve is assumed to be of the form  <em>y<sup>2</sup> + xy =x<sup>3</sup> + Ax<sup>2</sup> + B</em> . The field is defined with respect to the trinomial basis <em>t<sup>m</sup>+t<sup>a</sup>+1</em> or the pentanomial basis <em>t<sup>m</sup>+t<sup>a</sup>+t<sup>b</sup>+t<sup>c</sup>+1</em>. This routine can be called subsequently with the parameters of a different curve.</p>

<p><strong>Parameters:</strong>  The fixed point <em>G=</em>(<em>x,y</em>) on the curve  <em>y<sup>2</sup> + xy = x<sup>3</sup> + Ax<sup>2</sup> + B</em>, the field parameters <em>m, a, b, c.</em> Set <em>b</em> = 0 for a trinomial basis. The <em>type</em> parameter must be either <strong>MR_PROJECTIVE</strong> or ** MR_AFFINE**, and specifies whether projective or affine co-ordinates should be used internally. Normally the former is faster. If <em>check</em> is TRUE a check is made that the specified basis is irreducible. If FALSE, this basis validity check, which is time-consuming, is suppressed.</p>

<p><strong>Return value:</strong>  TRUE if parameters make sense, otherwise FALSE.</p>

<p><strong>Restrictions:</strong> Allocated memory will be freed when the current instance of MIRACL is terminated by a call to <strong>mirexit</strong>. However only one elliptic curve, GF(<em>p</em>) or GF(2_<sup>m</sup>_) may be active within a single MIRACL instance.</p>

<h3 id="9-3-9-ecurve_mult">9.3.9  ecurve_mult</h3>

<p><strong>Function:</strong>  void <strong>ecurve_mult</strong>(k,p,pa)</p>

<p>big k;
epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Multiplies a point on a GP(<em>p</em>) elliptic curve by an integer. Uses the addition/subtraction method.</p>

<p><strong>Parameters:</strong>  A big number <em>k</em>, and two points  <em>p</em> and <em>pa</em>. On exit <em>pa=k*p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The point <em>p</em> must be on the active curve.  </p>

<h3 id="9-3-10-ecurve2_mult">9.3.10  ecurve2_mult</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_mult</strong>(k,p,pa)</p>

<p>big k;
epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Multiplies a point on a GF(2_<sup>m</sup>_)  elliptic curve by an integer. Uses the addition/subtraction method.</p>

<p><strong>Parameters:</strong>  A big number <em>k</em>, and two points  <em>p</em> and <em>pa</em>. On exit <em>pa=k*p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The point <em>p</em> must be on the active curve.</p>

<h3 id="9-3-11-ecurve_mult2">9.3.11  ecurve_mult2</h3>

<p><strong>Function:</strong>  void <strong>ecurve_mult2</strong>(k1,p1,k2,p2,pa)</p>

<p>big k1,k2;
epoint *p1,*p2,*pa;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Calculates the point <em>k1.p1+k2.p2</em> on a GF(<em>p</em>) elliptic curve. This is quicker than doing two separate multiplications and an addition. Useful for certain cryptosystems. (See <em>ecsver.c</em> for example)</p>

<p><strong>Parameters:</strong>  Two big integers <em>k1</em> and <em>k2</em>, and three points <em>p1, p2</em> and <em>pa</em>.</p>

<p>On exit <em>pa = k1.p1+k2.p2</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The points <em>p1</em> and <em>p2</em> must be on the active curve.</p>

<h3 id="9-3-12-ecurve2_mult2">9.3.12  ecurve2_mult2</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_mult2</strong>(k1,p1,k2,p2,pa)</p>

<p>big k1,k2;
epoint *p1,*p2,*pa;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Calculates the point <em>k1.p1+k2.p2</em> on a GF(2_<sup>m</sup><em>) elliptic curve. This is quicker than doing two separate multiplications and an addition. Useful for certain cryptosystems. (See _ecsver2.c</em> for example)</p>

<p><strong>Parameters:</strong>  Two big integers <em>k1</em> and <em>k2</em>, and three points <em>p1, p2</em> and <em>pa</em>.</p>

<p>On exit <em>pa = k1.p1+k2.p2</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The points <em>p1</em> and <em>p2</em> must be on the active curve.</p>

<h3 id="9-3-13-ecurve_multi_add">9.3.13 ecurve_multi_add</h3>

<p><strong>Function:</strong>  void <strong>ecurve_multi_add</strong>(m,x,w)</p>

<p>int m;
epoint *x,*w;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Simultaneously adds pairs of points on the active GF(<em>p</em>) curve. This is much quicker than adding them individually, but <em>only</em> when using Affine co-ordinates.</p>

<p><strong>Parameters:</strong>  An integer <em>m</em> and two arrays of points <em>w</em> and <em>x</em>. On exit <em>w[i]=w[i]+x[i]</em> for <em>i</em> =0 to <em>m</em>-1</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Only useful when using Affine co-ordinates.</p>

<p><strong>See also:</strong>  <strong>ecurve_init</strong> and <strong>nres_multi_inverse</strong>, which is used internally.</p>

<h3 id="9-3-14-ecurve2_multi_add">9.3.14  ecurve2_multi_add</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_multi_add</strong>(m,x,w)</p>

<p>int m;
epoint *x,*w;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Simultaneously adds pairs of points on the active GF(2_<sup>m</sup>_) curve. This is much quicker than adding them individually, but only when using Affine co-ordinates.</p>

<p><strong>Parameters:</strong>  An integer <em>m</em> and two arrays of points <em>w</em> and <em>x</em>. On exit <em>w[i]=w[i]+x[i]</em> for <em>i</em> =0 to <em>m</em>-1</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  Only useful when using Affine co-ordinates.</p>

<blockquote>
<p>See also:  <strong>ecurve2_init</strong></p>
</blockquote>

<h3 id="9-3-15-ecurve_multn">9.3.15  ecurve_multn</h3>

<p><strong>Function:</strong>  void <strong>ecurve_multn</strong>(n,k,p,pa)</p>

<p>int n;
big *k;
epoint **p;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Calculates the point <em>k[0].p[0] + k[1].p[1] + â€¦ + k[n-1].p[n-1]</em> on a GF(<em>p</em>) elliptic curve, for <em>n&gt;2</em>.</p>

<p><strong>Parameters:</strong>  An integer <em>n</em>, an array of <em>n</em> big numbers <em>k[]</em>, and an array of <em>n</em> points. The result is returned in <em>pa</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The points must be on the active curve. The <em>k[]</em> values must all be positive. The underlying number base must be a power of 2.</p>

<h3 id="9-3-16-ecurve2_multn">9.3.16  ecurve2_multn</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_multn</strong>(n,k,p,pa)</p>

<p>int n;
big *k;
epoint **p;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Calculates the point <em>k[0].p[0] + k[1].p[1] + â€¦ + k[n-1].p[n-1]</em> on a GF(2_<sup>m</sup><em>) elliptic curve, for _n&gt;2</em>.</p>

<p><strong>Parameters:</strong>  An integer <em>n</em>, an array of <em>n</em> big numbers <em>k[]</em>, and an array of <em>n</em> points. The result is returned in <em>pa</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The points must be on the active curve. The <em>k[]</em> values must all be positive. The underlying number base must be a power of 2.</p>

<h3 id="9-3-17-ecurve_sub">9.3.17  ecurve_sub</h3>

<p><strong>Function:</strong>  void <strong>ecurve_sub</strong>(p,pa)</p>

<p>epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Subtracts two points on a GF(<em>p</em>) elliptic curve. Actually negates <em>p</em> and adds it to <em>pa</em>. Subtraction is quicker if <em>p</em> is normalised.</p>

<p><strong>Parameters:</strong>  Two points on the current active curve_, pa_ and <em>p</em>. On exit <em>pa = pa-p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The input points must actually be on the current active curve.</p>

<h3 id="9-3-18-ecurve2_sub">9.3.18  ecurve2_sub</h3>

<p><strong>Function:</strong>  void <strong>ecurve2_sub</strong>(p,pa)</p>

<p>epoint *p,*pa;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Subtracts two points on a GF(2_<sup>m</sup><em>) elliptic curve. Actually negates _p</em> and adds it to <em>pa</em>. Subtraction is quicker if <em>p</em> is normalised.</p>

<p><strong>Parameters:</strong>  Two points on the current active curve_, pa_ and <em>p</em>. On exit <em>pa = pa-p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The input points must actually be on the current active curve.</p>

<h3 id="9-3-19-epoint_comp">9.3.19  epoint_comp</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint_comp</strong>(p1,p2)</p>

<p>epoint *p1,*p2;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Compares two points on the current active GF(<em>p</em>) elliptic curve.</p>

<p><strong>Parameters:</strong>  Two points <em>p1</em> and <em>p2</em>.</p>

<p><strong>Return Value:</strong>  TRUE if the points are the same, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-20-epoint2_comp">9.3.20  epoint2_comp</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint2_comp</strong>(p1,p2)</p>

<p>epoint *p1,*p2;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Compares two points on the current active GF(2_<sup>m</sup>_) elliptic curve.</p>

<p><strong>Parameters:</strong>  Two points <em>p1</em> and <em>p2</em>.</p>

<p><strong>Return Value:</strong>  TRUE if the points are the same, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-21-epoint_copy">9.3.21  epoint_copy</h3>

<p><strong>Function:</strong>  void <strong>epoint_copy</strong>(p1,p2)</p>

<p>epoint *p1,*p2;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Copies one point to another on a GF(<em>p</em>) elliptic curve.</p>

<p><strong>Parameters:</strong>  Two points <em>p1</em> and <em>p2</em>. On exit <em>p2=p1</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-22-epoint2_copy">9.3.22  epoint2_copy</h3>

<p><strong>Function:</strong>  void <strong>epoint2_copy</strong>(p1,p2)</p>

<p>epoint *p1,*p2;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Copies one point to another on a GF(2_<sup>m</sup>_) elliptic curve.</p>

<p><strong>Parameters:</strong>  Two points <em>p1</em> and <em>p2</em>. On exit <em>p2=p1</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-23-epoint_free">9.3.23  epoint_free</h3>

<p><strong>Function:</strong>  void <strong>epoint_free</strong>(p)</p>

<p>epoint *p;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Frees memory associated with a point on a GF(<em>p</em>) elliptic curve.</p>

<p><strong>Parameters:</strong>  A point <em>p</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-3-24-epoint_get">9.3.24  epoint_get</h3>

<p><strong>Function:</strong>  int <strong>epoint_get</strong>(p,x,y)</p>

<p>epoint *p;
big x,y;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Normalises a point and extracts its <em>(x,y)</em> co-ordinates on the active GF(<em>p</em>) elliptic curve.</p>

<p><strong>Parameters:</strong>  A point <em>p</em>, and two big integers <em>x</em> and <em>y</em>. If <em>x</em> and <em>y</em> are not distinct variables on entry then only the value of <em>x</em> is returned.</p>

<p><strong>Return value:</strong>  The least significant bit of <em>y</em>. Note that it is possible to reconstruct a point from its <em>x</em> co-ordinate and just the least significant bit of <em>y</em>. Often such a &quot;compressed&quot; description of a point is useful.</p>

<p><strong>Restrictions:</strong>  The point <em>p</em> must be on the active curve.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* extract x co-ordinate and lsb of y */</span>
<span class="n">i</span><span class="o">=</span><span class="n">epoint_get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-3-25-epoint_getxyz">9.3.25  epoint_getxyz</h3>

<p><strong>Function:</strong>   void <strong>epoint_getxyz</strong>(p,x,y,z)</p>

<p>epoint *p;
big x,y,z;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Extracts the raw (<em>x,y,z</em>) co-ordinates of a point on the active GF(<em>p</em>) elliptic curve.</p>

<p><strong>Parameters:</strong>  A point <em>p</em>, and three big integers <em>x, y</em> and <em>z</em>. If any of these is NULL that coordinate is not returned.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>   The point <em>p</em> must be on the active curve.</p>

<h3 id="9-3-26-epoint2_get">9.3.26  epoint2_get</h3>

<p><strong>Function:</strong>  int <strong>epoint2_get</strong>(p,x,y)</p>

<p>epoint *p;
big x,y;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Normalises a point and extracts its <em>(x,y)</em> co-ordinates on the active GF(2_<sup>m</sup>_) elliptic curve.</p>

<p><strong>Parameters:</strong>  A point <em>p</em>, and two big integers <em>x</em> and <em>y</em>. If <em>x</em> and <em>y</em> are not distinct variables on entry then only the value of <em>x</em> is returned.</p>

<p><strong>Return value:</strong>  The least significant bit of <em>y/x</em>. Note that it is possible to reconstruct a point from its <em>x</em> co-ordinate and just the least significant bit of <em>y/x</em>. Often such a &quot;compressed&quot; description of a point is useful.</p>

<p><strong>Restrictions:</strong>  The point <em>p</em> must be on the active curve.</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/* extract x co-ordinate and lsb of y/x */</span>  
    <span class="n">i</span><span class="o">=</span><span class="n">epoint_get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-3-27-epoint2_getxyz">9.3.27  epoint2_getxyz</h3>

<p><strong>Function:</strong>   void <strong>epoint2_getxyz</strong>(p,x,y,z)</p>

<p>epoint *p;
big x,y,z;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Extracts the raw (<em>x,y,z</em>) co-ordinates of a point on the active GF(2_<sup>m</sup>_) elliptic curve.</p>

<p><strong>Parameters:</strong>  A point <em>p</em>, and three big integers <em>x, y</em> and <em>z</em>. If any of these is NULL that coordinate is not returned.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>   The point <em>p</em> must be on the active curve.</p>

<h3 id="9-3-28-epoint_init">9.3.28  epoint_init</h3>

<p><strong>Function:</strong>  epoint* <strong>epoint_init</strong>()</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Assigns memory to a point on a GF(<em>p</em>) elliptic curve, and initialises it to the &quot;point at infinity&quot;.</p>

<p><strong>Parameters:</strong>  None.</p>

<p><strong>Return value:</strong>  A point <em>p</em> (in fact a pointer to a structure allocated from the heap).</p>

<p><strong>Restrictions:</strong>  It is the C programmers responsibility to ensure that all elliptic curve points initialised by a call to this function, are ultimately freed by a call to <strong>epoint_free</strong>. If not a memory leak will result.</p>

<h3 id="9-3-29-epoint_init_mem">9.3.29  epoint_init_mem</h3>

<p><strong>Function:</strong>  epoint* <strong>epoint_init_mem</strong>(mem,index)</p>

<p>char *mem;
int index;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Initialises memory for an elliptic curve point from a pre-allocated byte array <em>mem</em>. This array may be created from the heap by a call to <strong>ecp_memalloc</strong>, or in some other way. This is quicker than multiple calls to <strong>epoint_init</strong></p>

<p><strong>Parameters:</strong>  A pointer to the pre-allocated array <em>mem</em>, and an index into that array. Each index should be unique.</p>

<p><strong>eturn value:</strong>  An initialised elliptic curve point.</p>

<p><strong>Restrictions:</strong>  Sufficient memory must have been allocated and pointed to by <em>mem</em>.</p>

<h3 id="9-3-30-epoint_norm">9.3.30  epoint_norm</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint_norm</strong>(p)</p>

<p>epoint *p;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Normalises a point on the current active GF(<em>p</em>) elliptic curve. This sets the <em>z</em> coordinate to 1. Point addition is quicker when adding a normalised point. This function does nothing if affine coordinates are being used (in which case there is no <em>z</em> co-ordinate)</p>

<p><strong>Parameters:</strong>  A point on the current active elliptic curve.</p>

<p><strong>Return value:</strong>  TRUE if successful.</p>

<h3 id="9-3-31-epoint2_norm">9.3.31  epoint2_norm</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint2_norm</strong>(p)</p>

<p>epoint *p;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Normalises a point on the current active GF(2_<sup>m</sup><em>) elliptic curve. This sets the _z</em> coordinate to 1. Point addition is quicker when adding a normalised point. This function does nothing if affine coordinates are being used (in which case there is no <em>z</em> co-ordinate)</p>

<p><strong>Parameters:</strong>  A point on the current active elliptic curve.</p>

<p><strong>Return value:</strong>  TRUE if successful.</p>

<h3 id="9-3-32-epoint_set">9.3.32  epoint_set</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint_set</strong>(x,y,lsb,p)</p>

<p>big x,y;
int lsb;
epoint *p;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Sets a point on the current active GF(<em>p</em>) elliptic curve (if possible).</p>

<p><strong>Parameters:</strong>  The integer co-ordinates <em>x</em> and <em>y</em> of the point <em>p</em>. If  <em>x</em> and <em>y</em> are not distinct variables then <em>x</em> only is passed to the function, and <em>lsb</em> is taken as the least significant bit of <em>y.</em> In this case the full value of <em>y</em> is reconstructed internally. This is known as &quot;point decompression&quot; (and is a bit time-consuming, requiring the extraction of a modular square root). On exit <em>p=(x,y)</em>.</p>

<p><strong>Return value:</strong>  TRUE if the point exists on the current active point, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/* decompress p */</span> 
    <span class="n">p</span><span class="o">=</span><span class="n">epoint_init</span><span class="p">();</span>
    <span class="n">epoint_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-3-33-epoint2_set">9.3.33  epoint2_set</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint2_set</strong>(x,y,lsb,p)</p>

<p>big x,y;
int lsb;
epoint *p;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Sets a point on the current active GF(2_<sup>m</sup>_) elliptic curve (if possible).</p>

<p><strong>Parameters:</strong>  The integer co-ordinates <em>x</em> and <em>y</em> of the point <em>p</em>. If  <em>x</em> and <em>y</em> are not distinct variables then <em>x</em> only is passed to the function, and <em>lsb</em> is taken as the least significant bit of <em>y/x.</em> In this case the full value of <em>y</em> is reconstructed internally. This is known as &quot;point decompression&quot; (and is a bit time-consuming, requiring the extraction of a field square root). On exit <em>p=(x,y)</em>.</p>

<p><strong>Return value:</strong>  TRUE if the point exists on the current active point, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/* decompress p */</span>
    <span class="n">p</span><span class="o">=</span><span class="n">epoint_init</span><span class="p">();</span>
    <span class="n">epoint2_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-3-34-epoint_x">9.3.34  epoint_x</h3>

<p><strong>Function:</strong>  BOOL <strong>epoint_x</strong>(x)</p>

<p>big x;</p>

<p><strong>Module:</strong>  mrcurve.c</p>

<p><strong>Description:</strong>  Tests to see if the parameter <em>x</em> is a valid co-ordinate of a point on the curve. It is faster to test an <em>x</em> co-ordinate first in this way, rather than trying to directly set it on the curve by calling <strong>epoint_set</strong>, as it avoids an expensive modular square root.</p>

<p><strong>Parameters:</strong>  The integer coordinate <em>x</em>.</p>

<p><strong>Return value:</strong>   TRUE if <em>x</em> is the coordinate of a curve point, otherwise FALSE</p>

<p><strong>Restrictions:</strong>   None</p>

<h3 id="9-3-35-mul_brick">9.3.35  mul_brick</h3>

<p><strong>Function:</strong>  int <strong>mul_brick</strong>(binst,e,x,y)</p>

<p>ebrick *binst;
big e,x,y;</p>

<p><strong>Module:</strong>  mrebrick.c</p>

<p><strong>Description:</strong>  Carries out a GF(<em>p</em>) elliptic curve multiplication using the precomputed values stored in the <em>ebrick</em> structure.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance, a big exponent <em>e</em> and a big number <em>w</em>. On exit (<em>x,y</em>) = <em>e.G</em> <em>mod n</em>, where <em>G</em> and <em>n</em> are specified in the initial call to <strong>ebrick_init.</strong> If <em>x</em> and <em>y</em> are not distinct variables, only <em>x</em> is returned.</p>

<p><strong>Return value:</strong>  The least significant bit of <em>y</em>.</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>ebrick_init</strong>.   </p>

<h3 id="9-3-36-mul2_brick">9.3.36  mul2_brick</h3>

<p><strong>Function:</strong>  int <strong>mul2_brick</strong>(binst,e,x,y)</p>

<p>ebrick2 *binst;
big e,x,y;</p>

<p><strong>Module:</strong>  mrec2m.c</p>

<p><strong>Description:</strong>  Carries out a GF(2_<sup>m</sup><em>)  elliptic curve multiplication using the precomputed values stored in the _ebrick2</em> structure.</p>

<p><strong>Parameters:</strong>  A pointer to the current instance, a big exponent <em>e</em> and a big number <em>w</em>. On exit (<em>x,y</em>) = <em>e.G</em>, where <em>G</em> is specified in the initial call to <strong>ebrick2_init.</strong> If <em>x</em> and <em>y</em> are not distinct variables, only <em>x</em> is returned.</p>

<p><strong>Return value:</strong>  The least significant bit of <em>y/x</em>.</p>

<p><strong>Restrictions:</strong>  Must be preceded by a call to <strong>ebrick2_init</strong>.</p>

<h3 id="9-3-37-point_at_infinity">9.3.37  point_at_infinity</h3>

<p><strong>Function:</strong>  BOOL <strong>point_at_infinity</strong>(p)</p>

<p>epoint *p;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>   Tests if an elliptic curve point is the &quot;point at infinity&quot;.</p>

<p><strong>Parameters:</strong>  An elliptic curve point <em>p</em>.</p>

<p><strong>Return value:</strong>  TRUE if <em>p</em> is the point-at-infinity, otherwise FALSE.</p>

<p><strong>Restrictions:</strong>  The point must be initialised.</p>

<h2 id="9-4-encryption-routines">9.4  Encryption Routines</h2>

<h3 id="9-4-1-aes_decrypt">9.4.1  aes_decrypt</h3>

<p>Function:  mrz_unsign32 aes_<strong>decrypt</strong>(a,buff)</p>

<p>aes *a;
char *buff;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Decrypts a 16 or <em>n</em> byte input buffer in situ.</p>

<p><strong>Parameters:</strong>  Pointer to an initialised instance of an <em>aes</em> structure defined in <em>miracl.h</em>, and to the buffer of bytes to be decrypted. If the mode of operation is as a block cipher (<strong>MR_ECB</strong> or <strong>MR_CBC</strong>) then 16 bytes will be decrypted. If the mode of operation is as a stream cipher (<strong>MR_CFB</strong><em>n</em>, <strong>MR_OFB</strong><em>n</em> or <strong>MR_PCFB</strong><em>n</em>) then <em>n</em> bytes will be decrypted.</p>

<p><strong>Return value:</strong>  In <strong>MR_CFB</strong><em>n</em> and <strong>MR_PCFB</strong><em>n</em> modes the <em>n</em> byte(s) that were shifted off the end of the input register as result of decrypting the <em>n</em> input byte(s), otherwise 0.</p>

<h3 id="9-4-2-aes_encrypt">9.4.2  aes_encrypt</h3>

<p><strong>Function:</strong>  mr_unsign32 <strong>aes_encrypt</strong>(a,buff)</p>

<p>aes *a;
char *buff;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Encrypts a 16 or <em>n</em> byte input buffer in situ.</p>

<p><strong>Parameters:</strong>  Pointer to an initialised instance of an <em>aes</em> structure defined in <em>miracl.h</em>, and to the buffer of bytes to be encrypted. If the mode of operation is as a block cipher (<strong>MR_ECB</strong> or <strong>MR_CBC</strong>) then 16 bytes will be encrypted. If the mode of operation is as a stream cipher (<strong>MR_CFB</strong><em>n</em>, <strong>MR_OFB</strong><em>n</em> or <strong>MR_PCFB</strong><em>n</em>) then a <em>n</em> bytes will be encrypted.</p>

<p><strong>Return value:</strong>  In <strong>MR_CFB</strong><em>n</em> and <strong>MR_PCFB</strong><em>n</em> modes the <em>n</em> byte(s) that were shifted off the end of the input register as result of encrypting the <em>n</em> input byte(s), otherwise 0.</p>

<h3 id="9-4-3-aes_end">9.4.3  aes_end</h3>

<p><strong>Function:</strong>  void <strong>aes_end</strong>(a)</p>

<p>aes *a;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Ends an AES encryption session, and de-allocates the memory associated with it. The internal session key data is destroyed.</p>

<p><strong>Parameters:</strong>  Pointer to an initialised instance of an <em>aes</em> structure defined in <em>miracl.h</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-4-aes_getreg">9.4.4  aes_getreg</h3>

<p><strong>Function:</strong>  void <strong>aes_getreg</strong>(a,ir)</p>

<p>aes *a;
char *ir;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Reads the current contents of the input chaining register associated with this instance of the AES. This is the register initialised by the IV in the calls to <strong>aes_init</strong>  and  <strong>aes_reset</strong>.</p>

<p>*<em>Parameters: *</em> Pointer to an instance of the <em>aes</em> structure, defined in <em>miracl.h</em>, and a character array to hold the extracted 16-byte data.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-5-aes_init">9.4.5  aes_init</h3>

<p><strong>Function:</strong>  BOOL <strong>aes_init</strong>(a,mode,nk,key,iv)</p>

<p>aes *a;
int mode,nk;
char *key,*iv;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Initialises an Encryption/Decryption session using the Advanced Encryption Standard (AES). This is a block cipher system that encrypts data in 128-bit blocks using a key of 128, 192 or 256 bits. See [Stinson] for more background on block ciphers.</p>

<p><strong>Parameters:</strong>  Pointer to an instance of the <em>aes</em> structure defined in <em>miracl.h,</em> the <em>mode</em> of operation to be used, an integer <em>nk</em> which specifies the size of the Key in bytes, and pointers to the key itself and the optional Initialisation Vector (IV). The mode can be one of <strong>MR_ECB</strong> (Electronic Code Book), <strong>MR_CBC</strong> (Cipher Block Chaining), <strong>MR_CFB</strong><em>n</em> (Cipher Feed-back where <em>n</em> is 1, 2 or 4), <strong>MR_PCFB</strong><em>n</em> (error Propagating Cipher Feed-back where <em>n</em> is 1, 2 or 4) or <strong>MR_OFB</strong><em>n</em> (Output Feed-back where <em>n</em> is 1, 2, 4, 8 or 16).  The value of <em>n</em> indicates the number of bytes to be processed in each application. For more information on Modes of Operation, see [Stinson]. <strong>MR_PCFB</strong><em>n</em> is an invention of our own [Scott93]. See below.</p>

<p>The value of <em>nk</em> can be 16, 24 or 32. A 16 bytes initialisation vector <em>iv</em> should be specified for all modes other than MR_ECB, in which case it can be NULL.</p>

<p><strong>Return value:</strong>  TRUE if initialisation succeeded, otherwise FALSE.</p>

<p><img src="dataassetsimagescunks9-1.png" alt=""></p>

<h3 id="9-4-6-aes_reset">9.4.6  aes_reset</h3>

<p><strong>Function:</strong>  void <strong>aes_reset</strong>(a,mode,iv)</p>

<p>aes *a;
int mode;
char *iv;</p>

<p><strong>Module:</strong>  mraes.c</p>

<p><strong>Description:</strong>  Resets the AES structure</p>

<p><strong>Parameters:</strong>  Pointer to an instance of the <em>aes</em> structure defined in <em>miracl.h</em>, an indication of the new <em>mode</em> of operation, and a pointer to a (possibly new) initialisation vector <em>iv</em>. See above for the modes allowed.</p>

<p><strong>Return value:</strong> None</p>

<h3 id="9-4-7-shs_init">9.4.7  shs_init</h3>

<p><strong>Function:</strong>  void <strong>shs_init</strong>(psh)</p>

<p>sha *psh;</p>

<p><strong>Module:</strong>  mrshs.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Secure Hash Algorithm SHA-1. Must be called before new use.</p>

<p><strong>Parameters:</strong>  Pointer to an instance of a structure defined in <em>miracl.h</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-8-shs_hash">9.4.8  shs_hash</h3>

<p><strong>Function:</strong>  void <strong>shs_hash</strong>(psh,hash)</p>

<p>sha *psh;
char hash[20];</p>

<p><strong>Module:</strong>  mrshs.c</p>

<p><strong>Description:</strong>  Generates a twenty byte (160 bit) hash value into the provided array.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and pointer to array to be filled.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-9-shs_process">9.4.9  shs_process</h3>

<p><strong>Function:</strong>  void <strong>shs_process</strong>(psh,ch)</p>

<p>sha *psh;
int ch;</p>

<p><strong>Module:</strong>  mrshs.c</p>

<p><strong>Description:</strong>  Processes a single byte. Typically called many times to provide input to the hashing process. The hash value of all the processed bytes can be retrieved by a subsequent call to <strong>shs_hash</strong>.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and character to be processed.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-10-shs256_init">9.4.10  shs256_init</h3>

<p><strong>Function:</strong>  void <strong>shs256_init</strong>(psh)</p>

<p>sha256 *psh;</p>

<p><strong>Module:</strong>  mrshs256.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Secure Hash Algorithm SHA-256. Must be called before new use.</p>

<p><strong>Parameters:</strong>  Pointer to an instance of a structure defined in <em>miracl.h</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-11-shs256_hash">9.4.11  shs256_hash</h3>

<p><strong>Function:</strong>  void <strong>shs256_hash</strong>(psh,hash)</p>

<p>sha256 *psh;
char hash[32];</p>

<p><strong>Module:</strong>  mrshs256.c</p>

<p><strong>Description:</strong>  Generates a 32 byte (256 bit) hash value into the provided array.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and pointer to array to be filled.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-12-shs256_process">9.4.12  shs256_process</h3>

<p><strong>Function:</strong>  void <strong>shs256_process</strong>(psh,ch)</p>

<p>sha256 *psh;
int ch;</p>

<p><strong>Module:</strong>  mrshs256.c</p>

<p><strong>Description:</strong>  Processes a single byte. Typically called many times to provide input to the hashing process. The hash value of all the processed bytes can be retrieved by a subsequent call to <strong>shs256_hash</strong>.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and character to be processed.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-13-shs384_init">9.4.13  shs384_init</h3>

<p><strong>Function:</strong>  void <strong>shs384_init</strong>(psh)</p>

<p>sha384 *psh;</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Secure Hash Algorithm SHA-384. Must be called before new use.</p>

<p><strong>Parameters:</strong>  Pointer to an instance of a structure defined in <em>miracl.h</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The SHA-384 algorithm is only available if 64-bit data-type is defined.</p>

<h3 id="9-4-14-shs384_hash">9.4.14  shs384_hash</h3>

<p><strong>Function:</strong>  void <strong>shs384_hash</strong>(psh,hash)</p>

<p>sha384 *psh;
char hash[48];</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Generates a 48 byte (384 bit) hash value into the provided array.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and pointer to array to be filled.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-15-shs384_process">9.4.15  shs384_process</h3>

<p><strong>Function:</strong>  void <strong>shs512_process</strong>(psh,ch)</p>

<p>sha384 *psh;
int ch;</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Processes a single byte. Typically called many times to provide input to the hashing process. The hash value of all the processed bytes can be retrieved by a subsequent call to <strong>shs384_hash</strong>.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and character to be processed.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-16-shs512_init">9.4.16  shs512_init</h3>

<p><strong>Function:</strong>  void <strong>shs512_init</strong>(psh)</p>

<p>sha512 *psh;</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Initialises an instance of the Secure Hash Algorithm SHA-512. Must be called before new use.</p>

<p><strong>Parameters:</strong>  Pointer to an instance of a structure defined in <em>miracl.h</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The SHA-512 algorithm is only available if 64-bit data-type is defined.</p>

<h3 id="9-4-17-shs512_hash">9.4.17  shs512_hash</h3>

<p><strong>Function:</strong>  void <strong>shs512_hash</strong>(psh,hash)</p>

<p>sha512 *psh;
char hash[64];</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Generates a 64 byte (512 bit) hash value into the provided array.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and pointer to array to be filled.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-18-shs512_process">9.4.18  shs512_process</h3>

<p><strong>Function:</strong>  void <strong>shs512_process</strong>(psh,ch)</p>

<p>sha512 *psh;
int ch;</p>

<p><strong>Module:</strong>  mrshs512.c</p>

<p><strong>Description:</strong>  Processes a single byte. Typically called many times to provide input to the hashing process. The hash value of all the processed bytes can be retrieved by a subsequent call to <strong>shs512_hash</strong>.</p>

<p><strong>Parameters:</strong>  Pointer to the current instance, and character to be processed.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-19-strong_bigdig">9.4.19  strong_bigdig</h3>

<p><strong>Function:</strong>  void <strong>strong_bigdig</strong>(rng,n,b,x)</p>

<p>csprng *rng;
int n,b;
big x;</p>

<p><strong>Module:</strong>  mrstrong.c</p>

<p><strong>Description:</strong>  Generates a big random number of given length from the cryptographically strong generator <em>rng</em>.</p>

<p><strong>Parameters:</strong> A pointer to the random number generator <em>rng</em>. A big number <em>x</em> and two integers <em>n</em> and <em>b</em>. On exit <em>x</em> contains a big random number <em>n</em> digits long to base <em>b</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The base <em>b</em> must be printable, that is 2 Â£ <em>b</em> Â£ 256.</p>

<h3 id="9-4-20-strong_bigrand">9.4.20  strong_bigrand</h3>

<p><strong>Function:</strong>  void <strong>strong_bigrand</strong>(rng,w,x)</p>

<p>csprng *rng;
big w,x;</p>

<p><strong>Module:</strong>  mrstrong.c</p>

<p><strong>Description:</strong>  Generates a cryptographically strong random big number <em>x</em> using the random number generator <em>rng</em> such that <em>0</em><em>Â£x &lt; w</em></p>

<p><strong>Parameters:</strong>  Two big numbers <em>w</em> and <em>x</em>, and a random number generator <em>rng</em></p>

<p><strong>Return value:</strong>   None</p>

<h3 id="9-4-21-strong_init">9.4.21  strong_init</h3>

<p><strong>Function:</strong>  void <strong>strong_init</strong>(rng,rawlen,raw,tod)</p>

<p>csprng *rng;
int rawlen;
char *raw;
long tod;</p>

<p><strong>Module:</strong>  mrstrong.c</p>

<p><strong>Description:</strong>  Initialize the cryptographically strong random number generator <em>rng</em>.</p>

<p><strong>Parameters:</strong>  A pointer to the random number generator <em>rng</em>. An array <em>raw</em> of length <em>rawlen</em> and a 32-bit time-of-day value <em>tod</em>. These two sources are used together to seed the generator. The former might be provided from random keystrokes, the latter from an internal clock. Subsequent calls to <strong>strong_rng</strong> will provide random bytes.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Example:</strong>  See <em>test1363.c</em> and <em>p1363.c</em> for an example of use.  </p>

<h3 id="9-4-22-strong_kill">9.4.22  strong_kill</h3>

<p><strong>Function:</strong>  void <strong>strong_kill</strong>(rng)</p>

<p>csprng *rng;</p>

<p><strong>Module:</strong>  mrstrong.c</p>

<p><strong>Description:</strong>  Kills the internal state of the random number generator <em>rng</em></p>

<p><strong>Parameters:</strong>  A pointer to a random number generator</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-4-23-strong_rng">9.4.23  strong_rng</h3>

<p><strong>Function:</strong> int <strong>strong_rng</strong>(rng)</p>

<p>csprng *rng;</p>

<p><strong>Module:</strong>  mrstrong.c</p>

<p><strong>Description:</strong>  Generates a sequence of cryptographically strong random bytes.</p>

<p><strong>Parameters:</strong>  A pointer to a random number</p>

<p><strong>Return value:</strong>  A random byte</p>

<h2 id="9-5-floating-slash-routines">9.5  Floating-Slash Routines</h2>

<h3 id="9-5-1-build">9.5.1  build</h3>

<p><strong>Function:</strong>  void <strong>build</strong>(x,gener)</p>

<p>flash x;
int (*gener)();</p>

<p><strong>Module:</strong>  mrbuild.c</p>

<p><strong>Description:</strong>  Uses supplied generator of regular continued fraction expansion to build up a flash number <em>x</em>, rounded if necessary.</p>

<p><strong>Parameters:</strong>  The flash number created, and the generator function.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This will calculate the golden ratio _(1+__Ã–5)/2_ in _x_ - very quickly!</span>
    <span class="kt">int</span> <span class="n">phi</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">flash</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">{</span> <span class="cm">/* rcf generator for golden ratio */</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="n">build</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">phi</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-5-2-dconv">9.5.2  dconv</h3>

<p><strong>Function:</strong>  void <strong>dconv</strong>(d,x)</p>

<p>double d;
flash x;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Converts a double to flash format.</p>

<p><strong>Parameters:</strong>  A double <em>d</em> and a flash variable <em>x</em>. On exit <em>x</em> will contain the flash equivalent of <em>d</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-3-denom">9.5.3  denom</h3>

<p><strong>Function:</strong>  void <strong>denom</strong>(x,y)</p>

<p>flash x;
big y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Extract the denominator of a flash number</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em> and a big number <em>y</em>. On exit <em>y</em> will contain the denominator of <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-4-facos">9.5.4  facos</h3>

<p><strong>Function:</strong>  void <strong>facos</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Description:</strong>  Calculates arc-cosine of a flash number, using <strong>fasin</strong>.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arccos(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  <em>|x|</em> must be less than or equal to 1.</p>

<h3 id="9-5-5-facosh">9.5.5  facosh</h3>

<p><strong>Function:</strong>  void <strong>facosh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Description:</strong>  Calculates hyperbolic arc-cosine of a flash number.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arccosh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  <em>|x</em>| must be greater than or equal to 1.</p>

<h3 id="9-5-6-fadd">9.5.6  fadd</h3>

<p><strong>Function:</strong>  void <strong>fadd</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Add two flash numbers.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x, y</em> and <em>z</em>. On exit <em>z=x+y</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-7-fasin">9.5.7  fasin</h3>

<p><strong>Function:</strong>  void <strong>fasin</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Description:</strong>  Calculates arc-sin of a flash number, using <strong>fatan</strong>.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arcsin(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  <em>|x</em>| must be less than or equal to 1.  </p>

<h3 id="9-5-8-fasinh">9.5.8  fasinh</h3>

<p><strong>Function:</strong>  void <strong>fasinh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Description:</strong>  Calculates hyperbolic arc-sin of a flash number.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arcsinh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-9-fatan">9.5.9  fatan</h3>

<p><strong>Function:</strong>  void <strong>fatan</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Desciption:</strong>  Calculates the arc-tangent of a flash number, using _O(n<sup>2.5</sup>)_method based on Newton&#39;s iteration.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arctan(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-10-fatanh">9.5.10  fatanh</h3>

<p><strong>Function:</strong>  void <strong>fatanh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Desciption:</strong>  Calculates the hyperbolic arc-tangent of a flash number.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=arctanh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  <em>x<sup>2</sup></em> must be less than 1</p>

<h3 id="9-5-11-fcomp">9.5.11  fcomp</h3>

<p><strong>Function:</strong>  int <strong>fcomp</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Compare two flash numbers.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>.</p>

<p><strong>Return value:</strong>  Returns -1 if <em>y&gt;x</em>, +1 if <em>x&gt;y</em> and 0 if <em>x=y</em>.</p>

<h3 id="9-5-12-fconv">9.5.12  fconv</h3>

<p><strong>Function:</strong>  void <strong>fconv</strong>(n,d,x)</p>

<p>int n,d;
flash x;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Convert a simple fraction to flash format.</p>

<p><strong>Parameters:</strong>  Integers <em>n</em> and <em>d</em>, and a flash number <em>x</em>.</p>

<p>On exit <em>x=n/d</em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-13-fcos">9.5.13  fcos</h3>

<p><strong>Function:</strong>  void <strong>fcos</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Description:</strong>  Calculates cosine of a given flash angle, using <strong>ftan</strong>.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=cos(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-14-fcosh">9.5.14  fcosh</h3>

<p><strong>Function:</strong>  void <strong>fcosh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Description:</strong>  Calculates hyperbolic cosine of a given flash angle.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=cosh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-15-fdiv">9.5.15  fdiv</h3>

<p><strong>Function:</strong>  void <strong>fdiv</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Divides two flash numbers.</p>

<p><strong>Parameters:</strong>  Three big numbers <em>x, y</em> and <em>z</em>. On exit <em>z=x/y</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-16-fdsize">9.5.16  fdsize</h3>

<p><strong>Function:</strong>  double <strong>fdsize</strong>(x)</p>

<p>flash x;</p>

<p><strong>Module:</strong>  mrdouble.c</p>

<p><strong>Description:</strong>  Converts a flash number to double format.</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em>.</p>

<p><strong>Return value:</strong>  The value of the parameter <em>x</em> as a double.</p>

<p><strong>Restrictions:</strong> The value of <em>x</em> must be representable as a double.</p>

<h3 id="9-5-17-fexp">9.5.17  fexp</h3>

<p><strong>Function:</strong>  void <strong>fexp</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh2.c</p>

<p><strong>Description:</strong>  Calculates the exponential of a flash number using <em>O(n<sup>2.5</sup>)</em> method.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=e<sup>x</sup></em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-18-fincr">9.5.18  fincr</h3>

<p><strong>Function:</strong>  void <strong>fincr</strong>(x,n,d,y)</p>

<p>big x,y;
int n,d;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Add a simple fraction to a flash number.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>, and two integers <em>n</em> and <em>d</em>.</p>

<p>On exit .</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<p><strong>Example:</strong></p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//This subtracts two-thirds from the value of _x_.</span>
    <span class="n">fincr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>
<h3 id="9-5-19-flog">9.5.19  flog</h3>

<p><strong>Function:</strong>  void <strong>flog</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong> mrflsh2.c</p>

<p><strong>Description:</strong>  Calculates the natural log of a flash number using <em>O(n<sup>2.5</sup>)</em> method.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=log(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-20-flop">9.5.20  flop</h3>

<p><strong>Function:</strong>  void <strong>flop</strong>(x,y,op,z)</p>

<p>flash x,y,z;
int *op;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Perform primitive flash operation. Used internally.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x, y</em> and <em>z</em>. On exit z_=Fn(x,y),_ where the function performed depends on the parameter <em>op</em>. See source listing comments for more details.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-21-fmodulo">9.5.21  fmodulo</h3>

<p><strong>Function:</strong>  void <strong>fmodulo</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Find the remainder when one flash number is divided by another.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x, y</em> and <em>z</em>. On exit <em>z=x mod y</em>;</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-22-fmul">9.5.22  fmul</h3>

<p><strong>Function:</strong>  void <strong>fmul</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Multiply two flash numbers.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x, y</em> and <em>z</em>. On exit <em>z=x.y</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-23-fpack">9.5.23  fpack</h3>

<p><strong>Function:</strong>  void <strong>fpack</strong>(n,d,x)</p>

<p>flash x;
big n,d;</p>

<p><strong>Description:</strong>  Forms a flash number from big numerator and denominator.</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em> and two big numbers <em>n</em> and <em>d</em>.</p>

<p>On exit .</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The denominator must be non-zero. Flash variable <em>x</em> and big variable <em>d</em> must be distinct. The resulting flash variable must not be too big for the representation.</p>

<h3 id="9-5-24-fpi">9.5.24  fpi</h3>

<p><strong>Function:</strong>  void <strong>fpi</strong>(x)</p>

<p>flash x;</p>

<p><strong>Module:</strong>  mrpi.c</p>

<p><strong>Description:</strong>  Calculates p using Guass-Legendre <em>O(n<sup>2</sup>.log n)</em> method. Note that on subsequent calls to this routine, p is immediately available, as it is stored internally. (This routine is disappointingly slow. There appears to be no simple way to calculate a rational approximation to p quickly).</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em>. On exit <em>x=</em><em>p.</em></p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None. Internally allocated memory is freed when the current MIRACL instance is ended by a call to <strong>mirexit</strong>.</p>

<h3 id="9-5-25-fpmul">9.5.25  fpmul</h3>

<p><strong>Function:</strong>  void <strong>fpmul</strong>(x,n,d,y)</p>

<p>flash x,y;
int n,d;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Multiplies a flash number by a simple fraction.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>, and two integers <em>n</em> and <em>d</em>.</p>

<p>On exit</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-26-fpower">9.5.26  fpower</h3>

<p><strong>Function:</strong>  void <strong>fpower</strong>(x,n,y)</p>

<p>flash x,y;
int n;</p>

<p><strong>Module:</strong>  mrflsh1.c</p>

<p><strong>Description:</strong>  Raises a flash number to an integer power.</p>

<p><strong>Parameters:</strong>  Flash variables <em>x</em> and <em>y</em>, and an integer <em>n</em>.</p>

<p>On exit <em>y=x<sup>n</sup></em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-27-fpowf">9.5.27  fpowf</h3>

<p><strong>Function:</strong>  void <strong>fpowf</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflsh2.c</p>

<p><strong>Description:</strong>  Raises a flash number to a flash power.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x</em>, <em>y</em> and <em>z</em>. On exit <em>z=x<sup>y</sup></em></p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-28-frand">9.5.28  frand</h3>

<p><strong>Function:</strong>  void <strong>frand</strong>(x)</p>

<p>flash x;</p>

<p><strong>Module:</strong>  mrfrnd.c</p>

<p><strong>Description:</strong>  Generates a random flash number.</p>

<p><strong>Parameters:</strong>  A big number <em>x</em>. On exit <em>x</em> contains a flash random number in the range <em>0 &lt; x &lt; 1</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-29-frecip">9.5.29  frecip</h3>

<p><strong>Function:</strong>  void <strong>frecip</strong> (x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Calculates reciprocal of a flash number.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=1/x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-30-froot">9.5.30  froot</h3>

<p><strong>Function:</strong>  BOOL <strong>froot</strong>(x,m,y)</p>

<p>flash x,y;
int m;</p>

<p><strong>Module:</strong>  mrflsh1.c</p>

<p><strong>Description:</strong>  Calculates <em>m</em>-th root of a flash number using Newton&#39;s <em>O(n<sup>2</sup>)</em> method.</p>

<p><strong>Parameters:</strong>  Flash numbers <em>x</em> and <em>y</em>, and an integer <em>m</em>.</p>

<p>On exit <em>y</em> is the <em>m</em>-th root of <em>x</em>.</p>

<p><strong>Return value:</strong>  TRUE for exact root, otherwise FALSE</p>

<h3 id="9-5-31-fsin">9.5.31  fsin</h3>

<p><strong>Function:</strong>  void <strong>fsin</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Description:</strong>  Calculates sine of a given flash angle. Uses <strong>ftan</strong>.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=sin(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-32-fsinh">9.5.32  fsinh</h3>

<p><strong>Function:</strong>  void <strong>fsinh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Description:</strong>  Calculates hyperbolic sine of a given flash angle.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=sinh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-33-fsub">9.5.33  fsub</h3>

<p><strong>Function:</strong>  void <strong>fsub</strong>(x,y,z)</p>

<p>flash x,y,z;</p>

<p><strong>Module:</strong>  mrflash.c</p>

<p><strong>Description:</strong>  Subtract two flash numbers.</p>

<p><strong>Parameters:</strong>  Three flash numbers <em>x, y</em> and <em>z</em>.</p>

<p>On exit <em>z=x-y</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-34-ftan">9.5.34  ftan</h3>

<p><strong>Function:</strong>  void <strong>ftan</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh3.c</p>

<p><strong>Description:</strong>  Calculates the tan of a given flash angle, using an <em>O(n<sup>2.5</sup>)</em> method.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=tan(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<h3 id="9-5-35-ftanh">9.5.35  ftanh</h3>

<p><strong>Function:</strong>  void <strong>ftanh</strong>(x,y)</p>

<p>flash x,y;</p>

<p><strong>Module:</strong>  mrflsh4.c</p>

<p><strong>Description:</strong>  Calculates the hyperbolic tan of a given flash angle.</p>

<p><strong>Parameters:</strong>  Two flash numbers <em>x</em> and <em>y</em>. On exit <em>y=tanh(x)</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-36-ftrunc">9.5.36  ftrunc</h3>

<p><strong>Function:</strong>  void <strong>ftrunc</strong>(x,y,z)</p>

<p>flash x,z;
big y;</p>

<p>**Module:  mrflash.c</p>

<p><strong>Description:</strong>  Separates a flash number to a big number and a flash remainder.</p>

<p><strong>Parameters:</strong>  Flash numbers <em>x</em> and <em>z</em>, and a big number <em>y</em>. On exit <em>y=int(x)</em> and <em>z</em> is the fractional remainder. If <em>y</em> is the same as <em>z</em>, only <em>int(x)</em> is returned.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-37-numer">9.5.37  numer</h3>

<p><strong>Function:</strong>  void <strong>numer</strong>(x,y)</p>

<p>flash x;
big y;</p>

<p><strong>Module:</strong>  mrcore.c</p>

<p><strong>Description:</strong>  Extract the numerator of a flash number.</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em> and a big number <em>y</em>.</p>

<p>On exit <em>y</em> will contain the numerator of <em>x</em>.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  None</p>

<h3 id="9-5-38-mround">9.5.38  mround</h3>

<p><strong>Function:</strong> void <strong>mround</strong>(n,d,x)</p>

<p>flash x;
big n,d;</p>

<p><strong>Module:</strong>  mrround.c</p>

<p><strong>Description:</strong>  Forms a rounded flash number from big numerator and denominator. If rounding takes place the instance variable <strong>EXACT</strong> is set to FALSE. <strong>EXACT</strong> is initialised to TRUE in routine <strong>mirsys</strong>. This routine is used internally.</p>

<p><strong>Parameters:</strong>  A flash number <em>x</em> and two big numbers <em>n</em> and <em>d</em>. On exit <em>x=R{n/d}</em>, that is the flash number <em>n/d</em> rounded if necessary to fit the representation.</p>

<p><strong>Return value:</strong>  None</p>

<p><strong>Restrictions:</strong>  The denominator must be non-zero.</p>


        <div class="tags">
            
        </div>

        

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'idrbwjekyll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </div>

      </div>

      <!-- Content Row -->

<div class="col-xs-12 col-sm-4 col-md-3">
  <div class="aside" id="asideAffix">
    <div class="title">Resources</div>

            <script>

                $(document).ready(function() {
                            // Initialize navgoco with default options
                            $("#mysidebar").navgoco({
                                caretHtml: '',
                                accordion: true,
                                openClass: 'active', // open
                                save: false, // leave false or nav highlighting doesn't work right
                                cookie: {
                                    name: 'navgoco',
                                    expires: false,
                                    path: '/'
                            },
                            slide: {
                                duration: 400,
                                easing: 'swing'
                                    }
                                    });

                $("#collapseAll").click(function(e) {
                    e.preventDefault();
                    $("#mysidebar").navgoco('toggle', false);
                });

                $("#expandAll").click(function(e) {
                    e.preventDefault();
                    $("#mysidebar").navgoco('toggle', true);
                });

                });

            </script>


            














            <ul id="mysidebar" class="nav">

                <span class="siteTagline">PRODUCTS</span>

                
                
                
            
                
                <li><a href="#">M-PIN CORE</a>
                    <ul>
                        
                        
                        
                        <li><a href="docs-m-pin-core.html">Overview</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-core-m-pin-core-3.3-release-notes.html">Release Notes 3.3</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-core-access.html">M-PIN Core Access</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-core-m-pin-in-browser-end-user-guide.html">M-Pin Core Brower User Guide</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-core-m-pin-in-mobile-end-user-guide.html">M-Pin Core Mobile End User Guide</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-core-m-pin-understanding-billing-options.html">M-Pin Core Billing</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">M-PIN SSO</a>
                    <ul>
                        
                        
                        
                        <li><a href="docs-m-pin-sso.html">Overview</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-sso-m-pin-sso-aws-3.3-release-notes.html">M-Pin SSO AWS 3.3 release Notes</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-sso-m-pin-sso-configuration-guide.html">Configuration</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="docs-m-pin-sso-m-pin-sso-for-aws-getting-started-guide.html">M-PIN SSO FOR AWS - Getting Started</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">Single-sourcing</a>
                    <ul>
                        
                        
                        
                        <li><a href="doc_conditional_logic.html">Conditional logic</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_content_reuse.html">Content reuse</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">Handling reviews</a>
                    <ul>
                        
                        
                        
                        <li><a href="doc_commenting_on_files.html">Commenting on files</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">Publishing</a>
                    <ul>
                        
                        
                        
                        <li><a href="doc_build_arguments.html">Build arguments</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_themes.html">Themes</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_link_validation.html">Link validation</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_generating_pdfs.html">Generating PDFs</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_excluding_files.html">Excluding files</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_help_api.html">Help APIs and UI tooltips</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_search_configuration.html">Search configuration</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_iterm_profiles.html">iTerm profiles</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_push_build_to_server.html">Pushing builds to server</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">Special layouts</a>
                    <ul>
                        
                        
                        
                        <li><a href="doc_kb_layout.html">Knowledge-base layout</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_scroll.html">Scroll layout</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_shuffle.html">Shuffle layout</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_faq.html">FAQ layout</a></li>
                        

                        

                
                
                        
                        
                        <li><a href="doc_glossary.html">Glossary layout</a></li>
                        

                        

                
                
    </ul>
            
            
                
                <li><a href="#">Tag archives</a>
                    <ul>
                        
                        
                        
                        <li><a href="tag_archives_overview.html">Tag archives overview</a></li>
                        

                        
                        
                        <li class="thirdlevel"><a href="#">Tag archive pages</a>
                            <ul>
                                
                                
                                
                                <li><a href="tag-getting-started.html">Getting started pages</a></li>
                                

                                
                                
                                
                                
                                <li><a href="tag-formatting.html">Formatting pages</a></li>
                                

                                
                                
                                
                                
                                <li><a href="tag-navigation.html">Navigation pages</a></li>
                                

                                
                                
                                
                                
                                <li><a href="tag-content-types.html">Content types pages</a></li>
                                

                                
                                
                                
                                
                                <li><a href="tag-publishing.html">Publishing pages</a></li>
                                

                                
                                
                                
                                
                                <li><a href="tag-special-layouts.html">Special layout pages</a></li>
                                

                                
                                
                            </ul>
                        </li>
                        
                        

                
                
    </ul>
            
            
            


    <div class="btn-row">
      <div class="btn-row">
        <a href="#" class="default-btn">
          <span class="txt">Download PDF</span>
        </a>
      </div>
    </div>
  </div>
</div>

<script>$("li.active").parents('li').toggleClass("active");</script>

      
    </div>
  </div>

</div>

1
</body>

<!-- the google_analytics_id gets auto inserted from the config file -->


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-66296557-1', 'auto');
    ga('send', 'pageview');
</script>



<div class="section dark footer">
	<div class="container">
		<div class="row">
			<div class="col-xs-6 col-sm-3 column">
				<h4 class="section-sub-title up">Products</h4>
				<ul class="list-unstyled">
					<li><a href="#">M-pin Core</a></li>
					<li><a href="#">M-pin SSO</a></li>
					<li><a href="#">Datacentre Cryptosystem</a></li>
					<li><a href="#">Cloud Security</a></li>
					<li><a href="#">Mobile</a></li>
				</ul>
			</div>
			<div class="col-xs-6 col-sm-3 column">
				<h4 class="section-sub-title up">Community</h4>
				<ul class="list-unstyled">
					<li><a href="#">Get Involved</a></li>
					<li><a href="#">How to contribute</a></li>
				</ul>
			</div>
			<div class="col-xs-6 col-sm-3 column">
				<h4 class="section-sub-title up">Resources</h4>
				<ul class="list-unstyled">
					<li><a href="#">Get started</a></li>
					<li><a href="#">Documentation</a></li>
					<li><a href="#"> GitHub</a></li>
				</ul>
			</div>
			<div class="col-xs-6 col-sm-3 column">
				<h4 class="section-sub-title up">Contact us</h4>
				<ul class="list-unstyled">
					<li>81 Rivington Street<br>United Kingdom, <br>EC2A 3AY</li>
					<li><a href="mailto:sales@miracl.com?Subject=Want%20to%20say%20hello!" target="_top">sales@miracl.com</a></li>
					<li><a href="tel:+4402033898190">+44 (0)20 3389 8190</a></li>
				</ul>
			</div>
		</div>
		<div class="row text-center">
			<ul class="list-inline small-footer">
				<li>MIRACL UK Ltd., All Rights Reserved.</li>
				<li><a href="https://www.certivox.com/about-certivox/terms-and-conditions">Terms and Conditions</a></li>
			</ul>
		</div>
	</div>
</div>

</html>

